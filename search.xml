<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS证书的那些事]]></title>
      <url>%2FiOS%E8%AF%81%E4%B9%A6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[提到iOS开发，肯定少不了与证书打交道。本文主要记录下个人对证书的一些理解，希望大家少踩坑。 概要虽然苹果整个生态链是封闭未开源的，但安全性在业内绝对靠前。证书，也可以说是数字签名，只是整个生态链安全性中的一环而已。无论是底层系统的设计，上架审核，还是对https的推行，以及近期火热的JSPatch等动态更新问题，都可以看出苹果还是很重视生态链的稳定和安全。 在这里，我并不会告诉你证书生成的具体流程，因为网上相关资料很多。 要想对app进行签名，需要拥有苹果开发者账号（个人或企业），在开发者中心创建根证书（开发development和生产production），然后在根证书的基础上，不同的应用application根据bundleId不一样，创建相应的推送证书、开发证书等一系列相关的证书。 如果发布应用，需要下载Apple全球开发者证书AppleWWDRCA.cer 苹果的证书，采用非对称加密算法，有公钥和私钥，通常我们所说的CSRCertificate Signing Request文件就是用来创建私钥的。所以，为了便于后续私钥的管理，建议所有证书用相同的CSR文件，CSR文件一直保留 当然，不同的证书可以有不同的CSR文件，只要你自己不嫌麻烦CSR文件是用KeyChain生成的(Keychain Access &gt; Certificate Assistant &gt; Request a Certificate From a Certificate Authority)。注意不要填写CA，邮箱最好填AppleId账号，名字看着取，最后选择存储到磁盘即可谁电脑创建的证书，需要将证书导出（KeyChain找到相应的证书，可以将展开的两个都选中，也就是公钥和私钥都选中，右键导出为p12文件），传给没有私钥的开发 应用支持的功能（GameCenter、PushNotification、InAppPurchase等），在开发者中心的Identifiers（即app IDs）里随时编辑的。 比如开始某app没有推送，后期接入推送，需要在app IDs里找到相应的bundleId开启PushNotification功能，然后生成推送证书 证书过期苹果的证书一般有效期是一年，即将过期时，开发者需要对证书进行更新，整个过程类似新建证书 对于即将过期的证书，并不需要撤销Revoke。如果一定要撤销，最好在新证书都搞定后，服务器也更新了相应的推送证书后，再操作（保证不影响线上产品）推送证书是和app的bundleId绑定的，服务器只需更新最新的推送证书即可，之前的版本也可以收到推送，无需重新发包企业证书等非appstore的证书(InHouse/AdHoc等)签发的安装包，一旦过期，必须用最新的证书重新打包，发布新版本(过期证书签发的包无法使用)。appstore证书签发的包，一旦过期，已存在的产品不受影响（注意：如果推送证书过期，还是必须更新推送证书的） 模拟推送将推送证书p12转换为pem文件，可以使用下面命令1openssl pkcs12 -in cert.p12 -out apple_push_notification.pem -nodes -clcerts 可以使用php、ruby、python、nodeJ等各种语言实现。 推荐个ruby写的推送模拟：Houston]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习正则表达式]]></title>
      <url>%2F%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[一直感觉正则表达式很神奇，非常强大，但并没有系统学习过，今天抽空过一遍，希望能够彻底掌握它 简介正则表达式在处理文本信息时非常有用，不限于代码、日志文件、文档等。在开始学习正则之前，需要有这种概念：任何文本都是由单个字符组成。 语法简单匹配 abcdefg、abcde、abc这三个字符串，用正则abc可以匹配前面三个串的abc字段abc123xyz、define”123”、var g=123，用正则123可以匹配三个公共的123数字 简单语法 \d 匹配任何0~9的数字；\D匹配任意非数字0~9的字符. 表示通配符，可以匹配任意字符。如果要匹配.，可以加入转义符\. Task Text Match cat. Match 896. Match ?=+. Skip abc1 上面的例子，正则...\.匹配前三个，最后一个不匹配 匹配特定的字符，使用[] Task Text Match can Match man Match fan Skip dan Skip ran Skip pan 上面的例子，需要匹配前三个，后三个不匹配，可用正则[cmf]an。[cmf]表示只匹配cmf之中的任意一个。 剔除特定字符,使用[^…] Task Text Match hog Match dog Skip bog 上面的例子，需要匹配前练个，最后一个不匹配，可用正则[^b]og，当然也可以用前面的匹配特定字符[hd]og 连续字符,使用-如果要匹配26个小写字母，难道我们要吧26个字母全部列出来么？当然可以，但太二了不是么。正则表达式用-表示连续的字符。如0-6相当于[0123456] Task Text Match Ana Match Bob Match Cpc Skip aax Skip bby Skip ccz 上面的例子，匹配前三个，后三个不匹配，可用正则[A-c][n-p][a-c] 注意，大写和小写字母是不同的字符，需要分开处理\w相当于[A-Za-z0-9_]，\W相当于[^A-Za-z0-9_] 字符个数的匹配,使用{}前面提到的额匹配都是单个字符的匹配，如果需要匹配3个数字，你也许会写成\d\d\d，但实际上有更好的写法，比如\d{3}。正则甚至支持范围，如a{1,3}表示最少有1个a，最多3个a。 Task Text Match wazzzzzup Match wazzzup Skip wazup 上面的例子，前两个匹配，最后一个不匹配，可用正则表达式waz{3,5}up 字符任意个数的匹配 *表示大于等于0个 +表示大于等于1个 比如，\d*表示任意个数字，但是\d+则表示最少要有一个数字 Task Text Match aaaabcc Match aabbbbc Match aacc Skip a 上面的例子，前三个匹配，最后一个不匹配，可用正则aa+b*c+ 标记某个字符可选，使用?由于？修饰的字符为可选，所以正则ab?c可以匹配abc或者ac。 Task Text Match 1 file found? Match 2 files found? Match 24 files found? Skip No files found. 上面的例子，前三个匹配，最后一个不匹配，可用正则\d+ files? found\? 空格、换行、对齐等字符空格&emsp;制表符tab(\t) 换行(\n) 回车(\r)。可以用\s来表示前面任意的空白符。同理，\S与\s相反，即各种空白符之外的字符。 Task Text Match 1.&emsp;abc Match 2.&emsp;&emsp;&emsp;&emsp;abc Match 3.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;abc Skip 4.abc 上面的例子，前三个匹配，最后一个不匹配，可用正则\d\.\s+abc 开始^和结束$需要注意的是，这里的开始^和例外[^...]的意义是不同的。假如需要验证用户的输入是否为5-12位数字组成的QQ号码，可以用^\d{5,12}$。 Task Text Match Mission: successful Skip Last Mission: unsuccessful Skip Next Mission: successful upon capture of target 上面的例子，第一个匹配，后两个不匹配，可用正则^Mission: successful$ 匹配并分组(…)正则表达式不仅仅可以用来匹配，还可以将匹配的结果进行分组group。比如，我们可以用正则表达式^(IMG\d+\.png)$找出所有照片,但是如果我们只需要照片名，不需要后缀名png呢，你会怎么做？这个时候可以用^(IMG\d+)\.png$ Task Text Capture file_record_transcript.pdf Capture file_07241999.pdf Skip testfile_fake.pdf.tmp 上面的例子，可用正则^(file.+)\.pdf$ 当然，分组还支持嵌套，用于更复杂的多重分组。如下，匹配日期并且列出年份 Task Text Capture Jan 1987 Capture May 1969 Capture Aug 2011 上面的例子，可用正则(\w+ (\d{4})) 条件匹配(…|…)假如你让别人给你带早餐，但你又不确定早餐店还剩下什么，这时候你会给别人几个备选项，在正则里可以用(..|..)来表示。如Buy more (milk|bread|juice) Task Text Match I love cats Match I love dogs Skip I love logs Skip I love cogs 上面的例子，可用正则I love (cats|dogs) 字符边界通常用\b表示字符的边界，与之相对的\B。现有字符串Chapter 1,可以用正则ter\b匹配得到ter，注意\b的位置，如果正则写成\bter则无匹配结果 练习匹配浮点数 Task Text Match 3.14529 Match -255.34 Match 128 Match 1.9e10 Match 123,340.00 Skip 720p 上面的例子，可用正则表达式^-?\d+(,\d+)*(\.\d+(e\d+)?)?$ 匹配图片 Task Text Skip .bash_profile Skip workspace.doc Capture img0912.jpg Capture updated_img0912.png Skip documentation.html Capture favicon.gif Skip img0912.jpg.tmp Skip access.lock 上面的例子，可用正则表达式(\w+)\.(jpg|png|gif)$ 说明本文参考链接regexone 文中的正则表达式只是示例，要达到同样的结果，正则表达式可能有多种写法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈MVC和MVVM]]></title>
      <url>%2F%E8%B0%88%E8%B0%88MVC%E5%92%8CMVVM%2F</url>
      <content type="text"><![CDATA[在IOS开发的过程中，你肯定听说过MVC下面记录下个人对这种设计模式的理解，顺便谈谈衍生的MVVM设计模式。 前言不管采用哪种设计模式，都是为了程序结构更清晰，便于后续扩展、复用，从某方面来说，程序员的最大敌人就是需求的不断更新和增加，而我们要做的就是：以不变应万变。这就需要相应的设计模式了，否则，我们的程序只会越来越庞大，到处都是冗余代码，无法维护和扩展，最终谁也拿它没辙。 换句话说，编码的原则是DRYDon&#39;t repeat yourself，如果你发现项目里有很多重复/类似的代码、某个类特别庞大、改需求特别痛苦、新项目完全从零起步，那我们就必须思考问题出在哪，并用相应的设计模式来重构代码，避免发生上述的状况 Model-View-Controller Model模型层，封装数据结构和相应的逻辑操作等。不能和视图层有直接的通信。用户在视图层的操作，通过控制层更新相应的模型层，然后通知控制层更新视图层界面。 View视图层是展现给用户看的，知道怎样布局，响应用户的操作。通常视图层需要和模型层解耦。模型层的改变，通过控制层来更新视图层的显示。 Controller控制层协调单个或多个模型和视图的关联，分配任务及管理app的生命周期等。 MVC模式里，Model、View和Controller相互独立，互不影响。通常为了实现需求，而没有将Controller进行拆分，导致Controller控制的状态过多，后期很难维护。需要将协调视图View和模型Model无关的代码抽出去，比如网络请求、数据库的读写等可以放到单独的模型Model里，Controller只需接受Model的更改并通知视图View更新即可。不同层不要相互引用，降低耦合。如：Model层不要直接引用View层，最好只引用同类别的Model MVC在IOS开发中的不足开发的过程中，由于Controller和View的紧耦合，导致MVC的三部分拆分并不完全独立，以及单元测试难以覆盖等问题。 Model-View-ViewModel 对比MVC，可以发现他们很相似，视图View和数据Model并没有直接通信，都要通过中间控制器协调（Controller或ViewModel）。那么在IOS开发中，ViewController和View都被划分到MVVM的视图层，Model还是模型层，ViewModel能主动调用Model的api对Model进行更改，也能在Model更改时对自身进行更新，然后通过View和ViewModel之间的绑定，对View进行更新。 View和ViewModel的绑定，常见的有两种方法 KVO 如Bond 函数式响应编程 如ReactiveCocoa]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017新的起点]]></title>
      <url>%2F2017%E6%96%B0%E7%9A%84%E8%B5%B7%E7%82%B9%2F</url>
      <content type="text"><![CDATA[博客从搭建到现在，中途荒废了好长一段时间，借口确实一大把，但是说到底就是懒呗(⊙﹏⊙) 2016过去一年，生活方面，进步确实挺小，希望今年可以改进。工作方面么，不在局限于Objective-C/Swift，也接触了一些前端知识，比如H5、Weex、Vue、React、JS、Webpack等一系列web前端和跨平台开发相关的知识点。可惜，除了参加大学同学的婚礼时去了趟杭州，就没去外地游玩过。 2017过去的就让它过去，新的一年里，还是有不少事情是必须完成的。别人的目标都是以亿为单位，我的目标藏在心里就好 (•̀ᴗ•́)。小目标还是可以贴几个的： 每个月最少读一本书 每个月最少发布两篇博客 调整作息时间，每天晚上23：00之前睡觉 小尾巴山重水复疑无路，柳暗花明又一村。Go，Go，Go！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios学习资料]]></title>
      <url>%2Fios%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
      <content type="text"><![CDATA[本文主要记录下常用的IOS学习资源 网站列表文章 英文 objc.io iOS Goodies NSHipster Ray Wenderlich Apple’s Swift Blog AppCoda IOSDevWeekly Medium Ry’s Cocoa Tutorial NSScreencast Use Your Loaf OleBegemann little bites of cocoa Toptal 中文 objc.io Cocoa China Code4App 文档 Apple Developer 社区 Stackoverflow 源码 Github 算法 Codefights 视频 WWDC视频 Stanford iTunes video 图标 The Noun Project 工具 Docker 如果你使用Docker，可以试试Kitematic和Captain Zeplin GitKraken 说明 欢迎各路大神评论，持续更新中。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码诊断Clang Diagnostics]]></title>
      <url>%2F%E4%BB%A3%E7%A0%81%E8%AF%8A%E6%96%ADClang-Diagnostics%2F</url>
      <content type="text"><![CDATA[注意本文转载自http://nshipster.cn/clang-diagnostics/ 概要诊断结合了逻辑与分析来得出一个结论。这是最纯粹的科学和工程学，也是人类最有力的推理。在医学界，诊断是通过实验室样本做后盾的本能来判断。而对于工业制造，则是通过在统计和方向都等同应用来诊断产品故障。 对于我们开发者来说，我们通过代码通知后续代码的生产，创建了一个在过去半个世纪里呈几何级数发展的技术的正反馈循环。尤其对于我们的 Objective-C 开发者来说，最有效的诊断来自 Clang。 Clang 是 C / Objective-C 的前端的 LLVM 编译器。它对 Objective-C 的语义和语法有着深刻的理解，而且更重要的原因是现在 Objective-C 已经是这样一个有能力的语言了。 当你在 XCode 中运行 “Build &amp; Analyze” (⌘⇧B) 后得到的惊人结果是 Clang 的更细腻，更深沉一面的功能：它的代码诊断。 在我们关于 #pragma 文章中，我们打趣的说： 资深提示：尝试设置 -Weverything 标志，并在你的编译设置中勾选上 “Treat Warnings as Errors”。这将在 Xcode 中开启困难模式。 现在，我们支持这个建议，并鼓励其他开发者更严肃的对待编译警告。然而，也有一些情况下，你和 Clang 会陷入僵局。例如，考虑以下 switch 语句：123456789switch (style) &#123; case UITableViewCellStyleDefault: case UITableViewCellStyleValue1: case UITableViewCellStyleValue2: case UITableViewCellStyleSubtitle: // ... default: return;&#125; 当启用这些标志后，Clang 会警告说 “default label in switch which covers all enumeration values”。然而，放大到一个更大的背景下，如果我们 知道 style 是（不管怎样）从外部来源的描述（如JSON资源），允许无约束的 NSInteger 值，则 default 情况是必要的保障。坚持这个必然性的唯一方法就是使用 #pragma 暂时忽略警告标志： push &amp; pop 用于保存和恢复编译器的状态，类似 Core Graphics 或 OpenGL 上下文。 123456789101112#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wcovered-switch-default"switch (style) &#123; case UITableViewCellStyleDefault: case UITableViewCellStyleValue1: case UITableViewCellStyleValue2: case UITableViewCellStyleSubtitle: // ... default: return;&#125;#pragma clang diagnostic pop 而且，怎么强调都不为过，Clang 至少在 99％ 的情况下都是对的。事实上修正一个分析警告 最好的 办法就是忽略它。使用 #pragma clang diagnostic ignored 作为最后的方法 最后，附上一份（基本上）全面的 Clang 警告综合列表，可以在这里找到：http://fuckingclangwarnings.com/ Clang警告列表的源码https://github.com/NSHipster/fuckingclangwarnings.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据打包和解包入门篇]]></title>
      <url>%2F%E6%95%B0%E6%8D%AE%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
      <content type="text"><![CDATA[数据的传输和获取，通常会涉及到数据的压缩和解压等操作如果现在有这么个需求 1、从服务器下载的图片，根据图片的二进制数据流决定图片的格式，你会怎么办? (数据截取)2、需要将用户每天24小时的生活状态传到服务器，然后可以按年/月/周/天取出并统计、展示等，你会怎么办？(字节数组) 对于上面的问题，我们就必须考虑数据结构，并实现压缩和解压等操作下面给予一个简单的示例，希望有所启示12345678910111213141516171819202122232425 //打包 int tmpSize = 10; Byte *tmpBuffer = malloc(sizeof(Byte)*tmpSize); for (int i = 0;i&lt;tmpSize;i++) &#123; tmpBuffer[i] = i; &#125; NSData *data = [[NSData alloc] initWithBytes:tmpBuffer length:tmpSize]; //解包 NSInteger length = data.length; Byte *parseBuffer = malloc(sizeof(Byte) * length); [data getBytes:parseBuffer length:length];// [data getBytes:parseBuffer range:NSMakeRange(0, length)]; Byte *p = parseBuffer; Byte *q = parseBuffer+length; while (p&lt;q) &#123; int parseValue = *p; NSLog(@"parse value is %d",parseValue); ++p; &#125; free(tmpBuffer); free(parseBuffer);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodeJS安装和更新]]></title>
      <url>%2FnodeJS%E5%AE%89%E8%A3%85%E5%92%8C%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[说明本文只记录macOSX系统，其它系统参考官网 安装HomeBrew安装12/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;brew install node 安装包官网下载最新安装包即可 更新HomeBrew安装的node1brew upgrade node 其它方式安装的node使用node的包管理工具n 123sudo npm cache clean -fsudo npm install -g nsudo n stable n简要说明sudo n version 可以安装指定node版本，如sudo n v4.4.5（如果电脑没有指定的版本，则会自动安装并将node切换到该版本；如果安装了，则直接切换到指定的版本）。n list可以查看所有的node版本n可以查看已安装的node版本 卸载 HomeBrew安装的brew uninstall node n安装的sudo n rm version shell脚本卸载1234567lsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom \| while read i; do sudo rm /usr/local/$&#123;i&#125;donesudo rm -rf /usr/local/lib/node \ /usr/local/lib/node_modules \ /var/db/receipts/org.nodejs.*]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios10简介]]></title>
      <url>%2Fios10%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[ios10新特性简介 概要个人感觉ios10的主要特性就是：开放、智能、便捷。 支持的设备 新特性短信iMessage 支持手写输入自定义消息框样式发送的内容可以选择先隐藏，接收者点击具体内容后才加载出来，营造惊喜模式支持自定义快捷回复和简单明了的点赞之类的快速交互表情支持类似微信生日快乐之类的动画效果支持文字和emoji转换开放第三方接口（类似微信的安装第三方聊天表情等) Siri 开放siri语音识别和处理等接口第三方app与siri的结合更智能。比如通过siri直接向微信里的特定好友发消息等。 照片photo 快捷搜索功能智能分类 地图 从ios7开始，苹果就致力于地图app功能的完善，但国内基本用不到。。。开放第三方接口。 通知 收到通知后，不用解锁，进入相应的app，用户可以直接处理消息。通知的外观也不再一成不变，第三方app可以自动以通知外观 智能家居 用户可以在桌面更智能便捷的控制家居等 电话 微信等的语音通话，可以直接调用系统的电话界面等来电识别等(如骚扰电话) 音乐、新闻 国内基本无用。。。 支付applePay 类似支付宝等的网页扫码支付 3D Touch 在桌面上的app图标上就可以使用3dTouch功能，而不用打开相应的app。 Widget 锁屏状态下，可以重新设计widget的外观]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios设备信息]]></title>
      <url>%2Fios%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%2F</url>
      <content type="text"><![CDATA[本文列举了常见的apple设备基本信息，主要包括ARM/Pixes/DPI/Size等信息 iPhone name hw.model ARM Pixes Points Size DPI/PPI iPhone 4 iPhone3,1iPhone3,2iPhone3,3 armv7 640x960 320x480 3.5英寸(89mm) 326 iPhone 4S iPhone4,1 armv7 640x960 320x480 3.5英寸(89mm) 326 iPhone 5 iPhone5,1iPhone5,2 armv7s 640x1136 320x568 4.0英寸(100mm) 326 iPhone 5C iPhone5,3iPhone5,4 armv7s 640x1136 320x568 4.0英寸(100mm) 326 iPhone 5S iPhone6,1iPhone6,2 arm64 640x1136 320x568 4.0英寸(100mm) 326 iPhone 6 Plus iPhone7,1 arm64 1080x1920 414x736 5.5英寸(140mm) 401 iPhone 6 iPhone7,2 arm64 750x1334 375x667 4.7英寸(120mm) 326 iPhone 6S iPhone8,1 arm64 750x1334 375x667 4.7英寸(120mm) 326 iPhone 6S Plus iPhone8,2 arm64 1080x1920 414x736 5.5英寸(140mm) 401 iPhone SE iPhone8,4 arm64 640x1136 320x568 4.0英寸(100mm) 326 iPad name hw.model ARM Pixes Points Size DPI/PPI iPad 1 iPad1,1 armv7 1024x768 1024x768 9.7英寸(250mm) 132 iPad 2 iPad2,1iPad2,2iPad2,3iPad2,4 armv7 1024x768 1024x768 9.7英寸(250mm) 132 iPad 3 iPad3,1iPad3,2iPad3,3 armv7 2048x1536 1024x768 9.7英寸(250mm) 264 iPad 4 iPad3,4iPad3,5iPad3,6 armv7s 2048x1536 1024x768 9.7英寸(250mm) 264 iPad Air 1 iPad4,1iPad4,2iPad4,3 arm64 2048x1536 1024x768 9.7英寸(250mm) 264 iPad Air 2 iPad5,3iPad5,4 arm64 2048x1536 1024x768 9.7英寸(250mm) 264 iPad Mini 1 iPad2,5iPad2,6iPad2,7 armv7 1024x768 1024x768 7.9英寸(200mm) 163 iPad Mini 2 iPad4,4iPad4,5iPad4,6 arm64 2048x1536 1024x768 7.9英寸(200mm) 326 iPad Mini 3 iPad4,7iPad4,8iPad4,9 arm64 2048x1536 1024x768 7.9英寸(200mm) 326 iPad Mini 4 iPad5,1iPad5,2 arm64 2048x1536 1024x768 7.9英寸(200mm) 326 iPad Pro iPad6,7iPad6,8 arm64 2732x2048 1356x1024 12.9英寸(330mm) 264 iPad Pro iPad6,3iPad6,4 arm64 2048x1536 1024x768 9.7英寸(250mm) 264 iPod name hw.model ARM Pixes Points Size DPI/PPI iPod 1 iPod1,1 armv6 320x480 320x480 3.5英寸(89mm) 163 iPod 2 iPod2,1 armv6 320x480 320x480 3.5英寸(89mm) 163 iPod 3 iPod3,1 armv7 320x480 320x480 3.5英寸(89mm) 163 iPod 4 iPod4,1 armv7 640x960 320x480 3.5英寸(89mm) 326 iPod 5 iPod5,1 armv7 640x1136 320x568 4.0英寸(100mm) 326 iPod 6 iPod7,1 arm64 640x1136 320x568 4.0英寸(100mm) 326 iWatch name hw.model ARM Pixes Points Size DPI/PPI Apple Watch Watch1,1Watch1,2 armv7k 272x340 136x170 1.337英寸(33.96mm) 326 Apple Watch Watch1,1Watch1,2 armv7k 312x390 156x195 1.534英寸(38.96mm) 326]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jenkins自动化集成]]></title>
      <url>%2FJenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[说明Jenkins很强大，本文主要记录Jenkins用于IOS自动打包。 步骤 Jenkins官网下载最新安装包 如果下载太慢，可以使用我的备份Jenkins1.651.2 双击下载的pkg文件，安装Jenkins。 安装完成后，在浏览器输入http://localhost:8080可以看到Jenkins的页面 提升jenkins的用户权限为管理员 12sudo dseditgroup -o edit -a jenkins -t user adminsudo dscl . append /Groups/_developer GroupMembership jenkins (可选) 补全Jenkins用户的信息 打开系统偏好设置，选择用户与群组,输入密码解锁。选择没有名字的那个用户，重新设置下密码，然后右键-&gt;高级选项，补全名字 从当前用户切换到jenkins。使用命令su -l 用户名(也可以重启电脑，选择jenkins用户登录，然后安装相关的证书。下面讲述的是命令行操作) 1su -l jenkins 为了方便从git等仓库拉取代码，生成SSH。(该过程最好全部默认，即一直按回车即可) 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; //邮箱为对应git仓库的用户名 使用cat命令查看SSH并复制出来，然后在相应的git仓库配置SSH即可。 由于我是命令行切换的用户，直接pbcopy是无用的，只能打印出来手动复制了。如果是登录时选择的Jenkins，可以使用pbcopy &gt; ~/.ssh/id_rsa.pub复制SSH 1cat ~/.ssh/id_rsa.pub 创建证书文件夹MobileDevice。将证书*.mobileprovision复制到Provisioning Profiles文件夹下 1234cd /Users/Shared/Jenkins/Librarymkdir MobileDevicecd MobileDevicemkdir &apos;Provisioning Profile&apos; 配置Jenkins 1.安全配置2.插件配置(默认没有git插件，需要自己安装) Xcode的工程配置里，Code Signing需要配置好相应的证书 给个参考的shell配置（注：工程采用了cocoapods管理第三方库） 重点在xcodebuild、xcrun命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#xxx为具体工程名，记得替换掉，目录结构也可能不一致，需微调echo &quot;start execute shell&quot;echo $(pwd)CURRENT_DIR=$(pwd)GIT_VER_NUM=$(git rev-list head | sort | wc -l)#GIT_COMMIT_ID=$(git rev-list head | head -1)#echo &quot;git version:$&#123;GIT_VER_NUM&#125;,commit id $&#123;GIT_COMMIT_ID&#125;&quot;PRO_DIR=&quot;$&#123;CURRENT_DIR&#125;/xxx&quot;cd $&#123;PRO_DIR&#125;WORKSPACE_DIR=&quot;$&#123;PRO_DIR&#125;/*.xcworkspace&quot;export LC_ALL=&quot;en_US.UTF-8&quot;/usr/local/bin/pod installPLIST_DIR=&quot;$&#123;PRO_DIR&#125;/xxx/xxx-Info.plist&quot;echo &quot;plist dir is $PLIST_DIR&quot;#打包前修改build号/usr/libexec/PlistBuddy -c &quot;Set CFBundleVersion $&#123;GIT_VER_NUM&#125;&quot; $&#123;PLIST_DIR&#125;APP_VERSION=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; $&#123;PLIST_DIR&#125;)APP_SHORT_VERSION=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; $&#123;PLIST_DIR&#125;)echo &quot;version $&#123;APP_VERSION&#125; build $&#123;APP_SHORT_VERSION&#125;&quot;RELEASE_IPA_DIR=$&#123;CURRENT_DIR&#125;/IOS#date +%Y%m%d%H%M%SBUILD_DATE=$(date +%Y%m%d%H%M)IPA_NAME=&quot;Release_$&#123;BUILD_DATE&#125;_xxx_V$&#123;APP_SHORT_VERSION&#125;.$&#123;APP_VERSION&#125;.ipa&quot;DSYM_NAME=&quot;Release_$&#123;BUILD_DATE&#125;_xxx_V$&#123;APP_SHORT_VERSION&#125;.$&#123;APP_VERSION&#125;.app.dSYM&quot;if [ -d $&#123;RELEASE_IPA_DIR&#125; ]; thenecho &quot;$&#123;RELEASE_IPA_DIR&#125; exist&quot;rm -rf $&#123;RELEASE_IPA_DIR&#125;/*.ipaelseecho &quot;$&#123;RELEASE_IPA_DIR&#125; do not exist, need create dir&quot;mkdir $&#123;RELEASE_IPA_DIR&#125;fiCONFIGURATION_INHOUSE=&quot;Release&quot;SCHEME=&quot;xxx&quot;BUILD_APP_DIR=&quot;$&#123;PRO_DIR&#125;/Build/Products/$&#123;CONFIGURATION_INHOUSE&#125;-iphoneos&quot;xcodebuild clean -workspace $WORKSPACE_DIR -scheme &quot;$&#123;SCHEME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION_INHOUSE&#125;&quot; -derivedDataPath &quot;$&#123;PRO_DIR&#125;&quot;xcodebuild -workspace $WORKSPACE_DIR -scheme &quot;$&#123;SCHEME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION_INHOUSE&#125;&quot; -derivedDataPath &quot;$&#123;PRO_DIR&#125;&quot;xcrun -sdk iphoneos PackageApplication -v $&#123;BUILD_APP_DIR&#125;/*.app -o $&#123;RELEASE_IPA_DIR&#125;/$&#123;IPA_NAME&#125;OUTDIR=&quot;/Users/Shared/Jenkins/IOS&quot;BUILD_DATE=$(date +%Y%m%d)OUT_IPA_DIR=$&#123;SEAFILEDIR&#125;/$&#123;BUILD_DATE&#125;if [ -d $&#123;OUT_IPA_DIR&#125; ]; thenecho &quot;$&#123;OUT_IPA_DIR&#125; exist&quot;elseecho &quot;$&#123;OUT_IPA_DIR&#125; do not exist, need create dir&quot;mkdir $&#123;OUT_IPA_DIR&#125;fimv $&#123;RELEASE_IPA_DIR&#125;/$&#123;IPA_NAME&#125; $&#123;OUT_IPA_DIR&#125;mv $&#123;BUILD_APP_DIR&#125;/*.dSYM $&#123;OUT_IPA_DIR&#125;/$&#123;DSYM_NAME&#125;###该处为非pod管理的工程关键代码#BUILD_APP_DIR=$&#123;CURRENT_DIR&#125;/xxx/build/$&#123;CONFIGURATION_INHOUSE&#125;-iphoneos/*.app#xcodebuild clean -project $PRO_DIR -target $&#123;TARGET_NAME&#125; -configuration $&#123;CONFIGURATION_INHOUSE&#125;#xcodebuild -project $PRO_DIR -target $&#123;TARGET_NAME&#125; -configuration $&#123;CONFIGURATION_INHOUSE&#125;#xcrun -sdk iphoneos PackageApplication -v $&#123;BUILD_APP_DIR&#125; -o $&#123;OUT_IPA_DIR&#125;/$&#123;IPA_NAME&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift入门篇]]></title>
      <url>%2FSwift%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
      <content type="text"><![CDATA[变量申明变量用var，常量用let；可以显示指明变量数据类型，也可以隐式由变量赋值决定。如果是可以为nil的变量，需要用可选符号?修饰。12345678910111213141516 let a: NSInteger = 12 var b = 13 b = 15 print(a+b) //2***********? var mayNilStr: String? = "hello"// var str: String = "world" mayNilStr = nil// str = nil print("\(mayNilStr)") //3********** ??(如果变量为nil，则取？？之后的值) var yourName :String? = nil yourName = "Tom" let defaultName = "Jack" let greet = "hello \(yourName ?? defaultName)" print(greet) 数组和字典数组和字典申明时可以显示指明元素、键值的数据类型，也可以隐式由包含的元素决定。1234567891011121314151617181920212223//1.可变数组和字典var shopping = ["catfish","water","tulips","blue paint"]shopping[0] = "beer"var dic1 = ["name": "Jack", "age": 12, "school": "Harverd"]dic1["key1"] = 8888.88print("shopping arr \(shopping)")print("dic1 list is \(dic1)")//2.空数组和空字典var emptyArray = [String]()var emptyDictionary = [String:Float]()emptyArray.append("111")emptyArray.insert("222", atIndex: 1)emptyDictionary["salary"] = 112.0/*var shoppingList = []var dicList = [:]*/print(emptyArray)print(emptyDictionary) 类型转换不同数据类型的转换，可以通过函数或者转义符实现。1234567891011121314//1********* 函数let label = "the width is "let width = 12let widthLabel = label + String(width)print(widthLabel)//2********** \()let apples = 3let oranges = 5let appleSummary = "I have \(apples) apples.\n"let orangeSummary = "I have \(oranges) oranges\n"let summary = "I have \(apples+oranges) pieces of fruit."print(appleSummary)print(orangeSummary)print(summary) 条件控制和for循环中，..&lt;表示小于，...表示小于等于。switch语句不在需要break并且支持模糊匹配等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//1 let scores = [12,35,86,98,13] for score in scores &#123; if score &lt; 60 &#123; print("\(score) is C") &#125;else if score &lt; 80 &#123; print("\(score) is B") &#125;else &#123; print("\(score) is A") &#125; &#125; //2 var c = 1000; while (c &gt; 0) &#123; c -= 100; &#125; print("final c value is \(c)") //3 let vegetable = "red pepper" switch vegetable &#123; case "celery" : print("Add some rausins and make ants on a log") case "cucumber", "watercress" : print("That would make a good tea sandwich") case let x where x.hasSuffix("pepper") : print("It is a spicy \(x)?") default : print("Everything tastes good in soup") &#125; //4 let numbers = [ "num1":[1,2,3,5,6,4,9,8], "num2":[12,15,17,86,23,11,90], "num3":[876,123,234,124,242,634] ] var largestNum = 0 for (_,kind) in numbers &#123; for num in kind &#123; if (num &gt; largestNum) &#123; largestNum = num; &#125; &#125; &#125; print("the largest num is \(largestNum)"); //5 var n = 2 repeat &#123; n = n*2 &#125;while n &lt; 100 print("final n is \(n)") //6 ****** ..&lt;小于 ...小于等于 var loop1 = 0 for i in 0..&lt;4 &#123; loop1 += i; &#125; print("loop1 value is \(loop1)") var loop2 = 0 for i in 0...4 &#123; loop2 += i; &#125; print("loop1 value is \(loop2)") 函数函数参数动态确定。可以作为参数或者返回值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func parameterFunction(name: String,age: Int16) -&gt; String &#123; return "your name is \(name), and age is \(age)"&#125;func calculateStaticstics(scores: [Int]) -&gt; (min: Int,max: Int,sum: Int) &#123; var min = 0 var max = 0 var sum = 0 for score in scores &#123; sum += score if (score &gt; max) &#123; max = score &#125; if (score &lt; min) &#123; min = score &#125; &#125; return (min,max,sum)&#125;func testDynamicParameter(numbers: Int...) -&gt; Int &#123; var sum = 0 for num in numbers &#123; sum += num &#125; if numbers.count &gt; 0 &#123; return sum/numbers.count &#125; return 0&#125;/** 返回值为函数 */func functionCanbeReturnType() -&gt; ((Int) -&gt; Int) &#123; func theReturnFunc(age: Int) -&gt; Int &#123; return age + 5 &#125; return theReturnFunc&#125;/** 参数为函数 */func functionCanbeParameter(lists:[Int],condition:((Int) -&gt; Bool)) -&gt; Bool &#123; for item in lists &#123; if (condition(item)) &#123; return true &#125; &#125; return false&#125; 类类中可以声明属性和方法等，可以创建构造函数和析构函数等123456789101112131415161718192021222324252627282930313233//类class Shape &#123; //property var numberOfSides = 0 var name: String? = nil var age: Int let extralProperty = 1 //构造函数 init(name: String)&#123; self.name = name self.age = 12 &#125; init(age: Int) &#123; self.age = age; &#125; init(name: String, age: Int) &#123; self.name = name self.age = age &#125; //实例销毁前的cleanup方法 deinit &#123; print("deinit method \(self.name)") &#125; //fucntion func shapeDescription() -&gt;String &#123; return "the shape side num is \(numberOfSides),name is \(name)" &#125;&#125; 继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Squar: Shape &#123; var sideLength: Double = 0.0 //property set and get method var perimeter: Double &#123; get &#123; return 4*sideLength &#125; set &#123; sideLength = sideLength/2 &#125; &#125; //enum(支持嵌入方法) enum Rank: Int &#123; case Ace = 1 case Two,Three,Four,Five,Six,Seven,Eight case Jack,Tom func simpleDescription() -&gt; String &#123; switch self &#123; case .Ace: return "ace" case .Jack: return "jack" case .Tom: return "tom" default: return String(self.rawValue) &#125; &#125; &#125; //struct struct Card &#123; var rank: Rank func simpleDescription() -&gt; String &#123; return "The \(rank.simpleDescription())" &#125; &#125; init(sideLength: Double, name: String) &#123; self.sideLength = sideLength; super.init(name: name) &#125; override func shapeDescription() -&gt; String &#123; return "override shape description" &#125;&#125; 协议123456789101112131415//声明协议protocol testProtocol &#123; var simpleProtocolMethod1: String &#123; get &#125; mutating func adjust()&#125;//实现协议class complishProtocol: testProtocol &#123; var simpleProtocolMethod1: String = "a very simple class" func adjust() &#123; simpleProtocolMethod1 += " Now 100% adjus" &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode的BuildSetting配置说明]]></title>
      <url>%2Fxcode%E7%9A%84BuildSetting%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[是否采用ARC 某个文件采用ARC，可以在Build Phases中的Compile Sources中找到该类，双击修改Compiler Flags为-fobjc-arc。 某个文件采用MRC，可以在Build Phases中的Compile Sources中找到该类，双击修改Compiler Flags为-fno-objc-arc。 全局宏定义一个workspace/project如果包含多个target或者scheme，可以在BuildSetting-&gt;Preprocessing-&gt;Preprocessor Macros中定义自己的宏来区别对待多target喝scheme等 第三方库路径配置有时第三方库（一般是.a之类的)引入时，查找路径没配好，可能导致编译失败。可以在BuildSetting-&gt;SearchPaths中修改库的查找路径为相对路径（不要用本地的绝对路径）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios各种指针说明]]></title>
      <url>%2Fios%E5%90%84%E7%A7%8D%E6%8C%87%E9%92%88%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[strong、weak、unsafe_unretained、autoreleasing、copy说明 strong 指针的默认类型。该指针指向的对象在指针存活期间一直存在，不会被销毁。 weak 当没有strong指针指向对象时，weak指针指向的对象将被销毁，同时weak指针为变为nil。 unsafe_unretained 该指针指向的对象销毁时，该指针不会被置为nil，而是被挂起(类似野指针)。最好别用 autoreleasing 一般指向函数的参数类型为id *并且自动释放的参数。 copy 类似strong，但是会复制一份新的对象（即指向新的内存地址），新指向的对象存活期同strong。 参考链接Apple]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[堆和栈的区别]]></title>
      <url>%2F%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[堆栈栈用于静态内存分配，堆用于动态内存分配，它们都存储在内存RAM里。 栈 栈上面的变量一般编译时就分配好了(如函数临时变量等)。栈遵循LIFO（后进先出），非常方便管理。 栈的内存分配一般由系统管理，开发者无需关心。 读取栈上的变量速度很快。 当一个方法function被调用时，它会被push进栈中，该方法中的参数和局部变量存储在栈中，当方法执行完后，该方法pop出来，相应的栈空间被释放。 堆 堆上的变量，一般在程序运行期分配。 读取堆上数据速度较慢。 堆上的元素能够在任何时候被读取，开发者也能够在任何时候申请堆内存空间并且释放申请的空间，所以管理堆上的变量比较复杂。 通常我们说的内存管理实际上是指堆内存管理。 堆的大小仅受限于虚拟内存的大小。 说明多线程开发中，每一个线程都有自己独立的栈，但是它们共享堆。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios app 性能优化的几个建议]]></title>
      <url>%2Fios-app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E4%B8%AA%E5%BB%BA%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[参考链接raywenderlich 优化建议当你开发了几款app后，是否考虑过怎样才能提高自己的app的性能。在开发的过程中，只要我们注意一些要点，可以很轻松地开发出性能优雅的app。这篇文章介绍了23个提高app性能的tips。 使用ARC和retain/release说拜拜。 使用重用机制特别是tableview/collectionview的cell，必须使用重用机制。 view的Opaque属性设置为YES不要在一个xib或者storyboard放置太多的东西因为每次系统加载xib到内存的时候，所有相关的内容都会加载（不管是否展现）,并且相关联的图片等资源也会被加载到内存（图片等还会缓存），很可能导致内存暴涨。 不要阻塞主线程耗时等操作在分线程执行，只有需要刷新界面是才在主线程。学会多线程开发和异步操作很有必要。 尽可能使图片的大小和imageview一样大网络下载的图片，可以先重画为imageview一样大小在显示。因为imageview拉伸或缩小图片代价较大，特别是当imageview嵌套在UIScrollview里的时候。 选用合适的数据容器。容器说明123* NSArrayi:有序的。能搞按照索引快速查找元素。按照值查找很慢，插入和删除很慢 * NSDictionary:无序的。键值对存储。按照key可以快速查找。* NSSet: 无序的。按照值可以快速查找，插入和删除很快。 服务器和客户端采用GZIP压缩可以减少网络交互的等待时间和流量。 尽量重用view。重复生成相同模板的view时，可以参照UITableview的重用机制，自己写一套reuse机制。只有在需要时才加载相关view，无关的view只有需要才加载。（如果为了更好的用户体验，在某些情况下可以预加载某些view并让它隐藏，需要时才显示） 缓存，缓存，缓存服务器的图片下载完成并缓存，以后就可以快速读取并加载。tableviewcell的高度也可以缓存。 考虑图片资源和绘图的代价某些效果是切图好还是代码绘制好，需要衡量下 响应系统发出的内存不足的警告如果收到内存不足的通知，需要马上释放缓存及其它可以再次创建的对象。 重用一些初始化比较慢的对象NSDateFormatter/NSCalendar等，一般可以在你的类中添加一个相应的property即可。12345678910111213141516171819202122// in your .h or inside a class extension@property (nonatomic, strong) NSDateFormatter *formatter; // inside the implementation (.m)// When you need, just use self.formatter- (NSDateFormatter *)formatter &#123; static NSDateFormatter *formatter; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy"; // twitter date format &#125;); return formatter;&#125;//这里用GCD可以避免多线程调用重复alloc的问题（如果某个属性不会被多个线程同时调用，不用这么复杂），如下：- (NSDateFormatter *)formatter &#123; if (! _formatter) &#123; _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy"; // twitter date format &#125; return _formatter;&#125; 游戏开发，使用sprite sheets尽量避免数据结构的来回转换服务器的json数据最好是不做处理就能直接使用，可以减少很多中间的转换过程。（如:json转成model）（汗!个人还是推荐转成model） 选择合适的数据类型服务器端发来的数据类型常见的有json和xml，具体看情况选择。xml支持边下载边解析，json必须下载完成才能开始解析。通常还是选择json 选择合适的背景图如果你有一张全屏的背景图，在底层价格UIImageView更好123// You could also achieve the same result in Interface BuilderUIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"background"]];[self.view addSubview:backgroundView]; 如果你有一张较小的带颜色的图，采用背景色较好1self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@"background"]]; 设置阴影路径当需要给一个view增加阴影效果时，你会怎么做？大部分的开发者会这样写：123456789#import &lt;QuartzCore/QuartzCore.h&gt; // Somewhere later ...UIView *view = [[UIView alloc] init]; // Setup the shadow ...view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);view.layer.shadowRadius = 5.0f;view.layer.shadowOpacity = 0.6; 看起来很简单，不是吗？但糟糕的是，这样并不好。CoreAnimation框架需要耗费不小代价才能绘制出阴影。好消息是，有一种更简单的方法：设置阴影路径。1view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath]; 缺点是，每次frame改变后，都需要更新shadow path。 优化tableview为了使tableview滑动更平滑，需要确保下面几项 cell复用 view的opaque属性尽可能设置为YES 避免渐变、图片伸缩、离屏渲染 如果cell高度不变，缓存计算出的高度 如果cell展示的内容包含网络请求的内容，缓存并且异步加载 阴影用shadow path 尽可能减少cell的subviews数量 在cellForRowAtIndexPath方法尽量少做事，如果必须做，尽可能缓存耗时操作的结果。 抽象出合理的数据结构来展示信息 直接设置rowHeight、SectionFooterHeight、SectionHeaderHeight的值，不要调用相应的代理delegate 选择合适的数据存储器当你需要存储/读取大量数据的时候，你会怎么做？一般有以下几个选择: 用NSUserDefaults存储 用格式化文件存储（如XML、JSON、Plist等） 归档（实现NSCoding协议） 数据库，如SQlite等 用IOS特有的Core Data NSUserDfault只适用于存储少量的数据。当你需要存储大量的数据时，其它选项更好格式化文件存储，缺点是你必须将整个文件读取到内存才能开始解析。好吧，那么NSCoding？但是它也是文件存储，缺点通格式化文件一样。最好的选择就是SQlite或CoreData。通过这种存储，你可以只加载需要的数据，并且不用写复杂的查询等语法。在性能方面，sqlite和coreData差不多。通常苹果建议使用coreData，但你也可以使用轻量型的Sqlite。如果你决定采用Sqlite存储，可以参考FMDB 复杂耗时操作异步执行@autoreleasepool可以保证块中的内容合理释放参考123456789NSArray *urls = &lt;# An array of file URLs #&gt;;for (NSURL *url in urls) &#123; @autoreleasepool &#123; NSError *error; NSString *fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; /* Process the string, creating and autoreleasing more objects. */ &#125;&#125; 图片是否在内存缓存ios有两种加载图片的方法 imageName imageWithContentOfFile 那么，这两种方法有什么区别呢？imageName会将加载的图片缓存到内存中，而imageWithContentOfFile仅仅加载图片，不缓存。如果加载大图并且调用次数很少，建议用imageWithContentOfFile。小图或者经常调用的图可以用imageName加载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git仓库迁移]]></title>
      <url>%2Fgit%E4%BB%93%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
      <content type="text"><![CDATA[说明如果你想从别的git托管服务器哪里复制一份源代码到新的git托管服务器上，可以通过以下步骤实现。 git仓迁移 从原地址克隆一份裸版本，比如原版本托管在github上。 1git clone --bare git://github.com/username/project.git 到新的git服务器上创建一个空的新项目，比如gitCafe服务器。 以镜像推送的方式，上传代码到gitCafe服务器上 12cd project.gitgit push --mirror git@gitcafe.com/username/newproject.git 删除本地之前克隆下来的裸版本 12cd ..rm -rf project.git 到新服务器gitCafe上找到clone地址，直接Clone到本地就可以了。 1git clone git@gitcafe.com/username/newproject.git 结束这种方式可以保留原版本库中的所有内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac电脑隐藏文件的方法]]></title>
      <url>%2Fmac%E7%94%B5%E8%84%91%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[工具terminal（终端） 显示mac电脑所有隐藏文件1defaults write com.apple.finder AppleShowAllFiles -bool true 隐藏mac电脑所有隐藏文件1defaults write com.apple.finder AppleShowAllFiles -bool false 主动隐藏某个文件(filename为想隐藏的文件的绝对路径名)1chflags hidden filename 主动取消某个文件的隐藏(filename为想隐藏的文件的绝对路径名)1chflags nohidden filename]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git使用方法]]></title>
      <url>%2Fgit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[git简介git官网有全套教程和说明，有兴趣的自己研究。如果你不适应命令行，可以使用GUI工具，如SourceTree。 官方文档中文官方文档。官方文档非常详细,需要仔细阅读。 常用命令 切换分支 1git checkout branchName 合并分支(将branchName合并到当前的分支) 1git merge --no-ff branchName 新建分支并切换到新建的分支 1git checkout -b branchName 删除分支 12git branch -d branchName //删除本地的分支git push &lt;shortname&gt; :branchName //删除远程分支 追加提交 123git commit -m &apos;initial commit&apos;git add forgotten_filegit commit --amend 取消暂存 1git reset HEAD fileName 撤销对文件的修改(**不可逆**) 1git checkout -- fileName 查看远程仓库的url 1git remote -v 添加新的远程仓库 1git remote add &lt;shortname&gt; &lt;url&gt; 拉取远程仓库的内容 12git fetch &lt;shortname&gt; [branchName] //不会合并，只拉取git pull &lt;shortname&gt; [branchName] //拉取并且合并 推送到远程仓库 1git push [shortname] [branch-name] 移除某个远程仓库 1git remote rm &lt;shortname&gt; 重命名远程仓库git remote rename 1git remote rename oldShortName newShortName 创建标签 1234git tag -a 1.2.0 -m &apos;my version 1.2.0&apos;//在之前的某次提交commitId打标签git tag -a 1.1.9 9fceb02 推送标签到远程仓库 12git push &lt;shortname&gt; --tags //推送所有本地标签git push &lt;shortname&gt; 1.2.0 //推送特定的标签 检出到特定的标签git checkout -b [branchname] [tagname] 1git checkout -b branchName 1.2.0 删除标签 12git tag -d tagName //删除本地的taggit push &lt;shortname&gt; --delete tag tagName //删除远程的tag 设置git别名 12345git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.unstage &apos;reset HEAD --&apos; 版本回退 1git reset --hard HEAD ~N //N为数字，回退N个版本 撤销某次提交 1git revert commitId 文件权限不纳入版本管理 1git config core.filemode false 子模块 12git submodule add 仓库url 本地路径 //添加子模块git submodule update —init —recursive //下载带有子模块的repo后 暂存。当某个任务完成了一半，但突然插进来一个其它的紧急任务，这个时候你又不能将未完成的工作commit，暂存stash就非常有用了。 1234567git stash save &quot;some comments for this stash&quot; //暂存并添加注释，方便后续取出git stash list //查看当前所有的暂存git stash apply stash@&#123;0&#125; //取出最后一次的暂存(具体想取出哪次暂存，通过git stash list查看)git stash drop stash@&#123;0&#125; //将最后一次的暂存从暂存列表清除git stash clear //清除所有暂存git stash pop //取出最后一次暂存，并将其从暂存列表清除git stash branch newBranch stash@&#123;0&#125; //取出最后一次暂存并切换到新的分支newBranch，同时将其从暂存列表清除 附录查看git的总提交次数(可以作为版本号之类的)1git rev-list head | sort | wc -l 查看git最后一次提交的hash值1git rev-list head | head -1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[app提交appstore的简介]]></title>
      <url>%2Fapp%E6%8F%90%E4%BA%A4appstore%E7%9A%84%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[申请开发者账号 登陆苹果官网Apple Develper,注册开发者账号 生成certificate证书(用系统的keychain生成.CSR文件，该文件最好长期保存，后续加入新app或者证书过期需重新生成时都需要该文件，这样服务器就不用更新推送证书了，而且兼容之前老证书发的包)，生成对应的证书打包提交AppStore。（个人开发者账号打的包提交appstore，企业开发者账号打的是Inhouse证书的包，无需通过appstore，可以直接通过fir等分发就行） 登陆Itunes Connect,创建App Itunes Connect注意事项 AppIcon,尺寸1024*1024px,包括Ipad和Iphone Screenshots,app截图，最多5张，以竖屏为例子 Iphone4/4s: 640*960px Iphone5/5s: 640*1136px Iphone6: 750*1334px Iphone6 plus: 1242*2208px Ipad: 1536*2048px 基本信息 app的描述 关键字，多个关键字逗号隔开，用于appStore搜索 技术支持网站 推广网站 可选 隐私声明网站 可选 app的类别，如教育-工具 年龄评级，勾选相关项，系统会自动计算 设置价格 根据实际产品，选择性设置In-AppPurchase、Game Center、Newsstand等 可选 发布的市场。默认全球appStore上线，如果要求在特定区域的市场上线，需要提交.geojson格式的文件 可选 发布方式。默认是审核通过就发布到appStore，也可以选择手动发布 版权信息 版权所有，如“2015 Acme Inc” 负责人姓名、手机、邮箱 审核 审核时遇到问题时的联系人：姓名、手机、邮箱 审核时的测试账号(长期有效，最高权限) 审核时的注意事项和备注 将通过测试验收的工程，Xcode等工具打包并添加相应的证书，提交appStore 确认符合苹果审核要求 进入Itunes Connect，确认信息完整后，点击右上角的提交审核按钮]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cocoapods安装和使用入门篇]]></title>
      <url>%2Fcocoapods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
      <content type="text"><![CDATA[cocoapods是Xcode管理第三方类库的工具（当然也可以管理自己封装的私有库），能够处理类库之间的依赖关系，方便多个类库的升级和管理。它是用ruby语言编写的。 一、更换ruby源(ruby官方源很可能被墙了)打开命令行窗口terminal，依次输入下面的命令12gem sources --remove https://rubygems.org/gem sources --add https://ruby.taobao.org/ 接着输入gem sources -l即可看到如下结果123*** CURRENT SOURCES ***https://ruby.taobao.org/ 最好顺便更新下gem，输入命令sudo gem update --system即可。（可选） 二、安装cocoapods 安装最新版本sudo gem install -n /usr/local/bin cocoapods 安装指定版本sudo gem install -n /usr/local/bin cocoapods --version 1.0.0 三、下载pod仓库索引输入pod setup开始下载索引表，该过程耗时较长，请耐心等待。如果下载一个小时还遥遥无期，那你可以从别人做的镜像下载索引表，步骤如下123pod repo remove masterpod repo add master https://git.coding.net/jasper/CocoaPods.gitpod repo update 上面从镜像下载索引表的命令同样适用于私有库（如：公司内部搭建的各种私有库git索引表），只需输入pod repo add [repoName] url 时repoName不一样就行。cocoapods支持多个源（官方源和私有源等） 四、更新pod索引表每天都有人上传和更新pod仓库，所以最好定时更新pod索引表1pod repo update 五、升级cocoapods版本其实升级和安装的命令一样 升级到最新版本sudo gem install -n /usr/local/bin cocoapods 升级到指定版本sudo gem install -n /usr/local/bin cocoapods --version 1.0.0 六、使用cocoapods工程根目录下新建文件Podfile（该文件无后缀名）,编辑Podfile里的内容 pod版本低于1.0.0 12platform:ios, &apos;7.0&apos;pod &apos;AFNetworking&apos;, &apos;~&gt; 2.3.1&apos; pod版本大于等于1.0.0 1234567891011121314151617181920212223#官方源source &apos;https://github.com/CocoaPods/Specs.git&apos;#如果有内部私有源，再添加一条source即可platform :ios, &apos;7.0&apos;#use_frameworks!inhibit_all_warnings!target &apos;targetName&apos; dopod &apos;AFNetworking&apos;, &apos;~&gt; 2.3.1&apos;end#修改工程配置等，根据情况配置，可选post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;] = &apos;7.0&apos; if target.name == &apos;OpenCore&apos; config.build_settings[&apos;ENABLE_BITCODE&apos;] = &apos;NO&apos; end end endend 七、安装第三方库使用pod install安装第三方库。如果修改过Podfile文件(增加/删除podame)，需要使用pod install，而不是pod update。update命令若不指定podName则更新所有有新版本的库pod update [podName] 使用pod install后，需要点击*.xcworkspace打开工程，而不是以前的*.project 八、卸载cocoapods输入命令sudo gem uninstall cocoapods即可卸载cocoapods 每次执行pod install后，Podfile.lock都会更新。如果团队使用git/svn之类的版本管理工具，必须将Podfile.lock纳入版本管理。否则，团队中不同的人看到的cocoapods管理的第三方库版本可能不一致，甚至报错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IOS生成静态库.a文件]]></title>
      <url>%2FIOS%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%BA%93-a%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[说明库是程序代码的合集，常见的有开源库和闭源库，其中.a就是闭源库（无法看到具体实现方法），而Github上的代码基本都是开源库。静态库执行时会被复制到可执行文件中，多次调用则会出现冗余拷贝，不建议使用静态库。可以使用动态库.dylib(动态库貌似通不过appstore审核)或者源码。 生成.a文件一个.a文件，要想兼容各种不同的cpu架构，需要包含各种指令集(amrv7/armv7s/arm64/i386/x86_64等)。常用的查看和合并.a文件的指令lipo。 步骤和说明 打开Xcode创建新工程，选择相应的系统，本文以IOS系统为例。选择Framework&amp;Library中的Cocoa Touch Static Library。接着输入工程名字即可。 新建文件夹。暂时取名StaticDemo,所有需要打包生成.a的文件都将放在该目录下。 在StaticDemo目录下分别创建3个类TestPublicClass/TestObj1/TestObj2，其中TestPublicClass.h准备对外公开。 随便选择一个模拟器(如iphoen6)，Command+B编译完成后就会生成.a文件，该文件是用于模拟器的（Release版本可以不合并），然后选择Generic IOS Device，再次编译完成，会生成.a文件，该文件是用于真机的。 他们的路径可以右键.a文件在Finder中查看。 查看.a文件支持的arm指令集，使用lipo -inof *.a,如: 12lipo -info libGenerateStaticLib.a Architectures in the fat file: libGenerateStaticLib.a are: armv7 arm64 合并不同架构的.a文件，使用命令lipoi -create source1.a source2.a -output dest.a，如： 1lipo -create Debug-iphoneos/libGenerateStaticLib.a Debug-iphonesimulator/libGenerateStaticLib.a -output libGS.a 合并后，可以通过lipo -info *.a确认 12lipo -info libGS.a Architectures in the fat file: libGS.a are: armv7 x86_64 arm64 可以看到.a已经合并成功。接着将头文件TestPublicClass.h复制出来，.a文件打包就大功告成了。 iphone设备arm架构表参考链接 device name ARM iphone4s及之前 armv7 iphone5/5c armv7s iphone5s/6/6s/6p/se arm64 结束arm指令能够向下兼容，所以只需32和64位各一个.a文件就行了。目前xcode7.2默认的architecture为armv7和arm64，已经能够适应任何iphone设备了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo个人博客之搜索引擎推广]]></title>
      <url>%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8E%A8%E5%B9%BF%2F</url>
      <content type="text"><![CDATA[说明前段时间抽空搭建了个人博客，来回也折腾了不少时间，好不容易写了点东西，发现搜索引擎居然不能找到自己写的东西，于是就开始研究了下搜索引擎推广。 平台我的博客采用Hexo框架搭建的，存储在Github上。然后自己买了个域名，现在博客主页基本配置完成我的主页。 确认自己网站是否被收录在浏览器的搜索框输入site:zyoung.me，查看搜索结果就能明白了。（这个域名是我的，大家换成自己的网站域名就可以了）。提供下Google和Baidu的网站验证入口 Google搜索引擎提交入口 Baidu搜索引擎提交入口 如果你的博客也在gitHub上，百度搜索引擎估计不好用（Github屏蔽了百度的抓取)。 验证网站一般验证域名所有权有很多方法，但是最简单的还是下载html文件到网站的根目录下。如果你的博客是hexo的框架搭建的，需要注意: 下载的html文件需要放在source目录下，而不是手动添加到根目录下，类似的CNAME也需要放在source目录下。 由于hexo发布时，默认会对文件进行格式化等操作，但是我们下载的验证文件是不允许做格式化等操作的（会导致验证文件内容更改），否则验证无法通过。需要告诉hexo不要格式化特定的文件，需要在文件内容加入以下内容:12layout: false--- 所以，最终Google的验证文件内容cat出来为123layout: false---google-site-verification: google*******.html 站点地图sitemap.xml验证网站后，一般还需要生成站点地图，进一步方便搜索引擎抓取网站的内容。如果使用hexo的小伙伴，可以直接使用插件，发布时会自动生成sitemap。12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 生成的sitemap文件在public目录 结束语暂时就这么多吧，其他的比如百度push、结构化数据标记等高阶内容，暂时还没研究]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown学习笔记]]></title>
      <url>%2Fmarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[markdown的目标是实现: 易读易写1、兼容html。A paragraph in HTML displayed as code 1&lt;p&gt;A paragraph in &lt;b&gt;HTML&lt;/b&gt; displayed as code&lt;/p&gt; 2、不在markdown涵盖范围之内的标签，都可以直接在文档里用html编写，不需要额外标注。3、html文件中，有两个字符需要特殊处理：&lt;&amp;lt;和&amp;&amp;amp;。&lt;用于起始标签，&amp;用于标记html实体。插入版权符号&copy;&amp;copy;4、段落的前后要有一个以上的空行，普通段落不需要空格或制表符来缩进。 5、支持两种标题的语法，类Setext和类atx形式。例如：12345This is an H1============This is an H2------------ 任何数量的=和-都可以有效果。也可以选择类Atx形式在行首插入1到6个#,对应1到6阶标题，例如:12# 这是H1###### 这是H6 6、区块引用Blockquotes，在段落前加上&gt;来标记区块引用。可以叠加嵌套，例 This is the first level of quoting. This is nested blockquote. Back to the first level. 7、列表markdown支持无序和有序列表。无序列表使用星号、加号或减号作为列表标记123* Red* Green* Blue 有序表则使用数字接着一个英文句点:1231. Bird2. Mchale3. Parish 列表项中可以包含多个段落，每个分类下的段落必须缩进4个空格或1个制表符123456781. This is a list item with two paragraphs. Lorem ipsum dolor sit amet,consiter adipiscing elit. A;iquam henderit mi posure lecture Greateful. Another paragraph2. Suspend id is what a good.3. Third item 8、建立分割线。可以在一行中用三个以上的星号、减号、底线来建立分割线。也可以在星号和减号之间插入空格123***---* * * 9、链接[tittle](url)markdown中文网站 markdownmarkdown的VIM编辑器 vim-markdown 10、图片![title](imgUrl)This is an image 11、表格 Colum1 Colum2 Colum3 Colum4 中对齐 中对齐 左对齐 右对齐 中对齐 好的好的 哈 简单介绍 中对齐 但是 动画 哈哈 表格代码如下:12345|Colum1|Colum2 |Colum3 | Colum4 ||:----:|:----: |:----- | -------:||中对齐|中对齐 |左对齐 | 右对齐 ||中对齐|好的好的|哈 | 简单介绍||中对齐|但是 |动画 | 哈哈 | 12、锚点链接1234之前的第一条定义如下：&lt;a name=&quot;html&quot;&gt;1、兼容html。&lt;/a&gt;然后可以直接锚点跳转过去，使用方法如下:[锚点名称](#锚点名) 13、视频链接其实就是插入视频截图然后将链接设置为视频的实际地址[![vedio](/ios10/ios10_preview.png)](http://open.163.com/movie/2011/10/F/G/M7GF17HPS_M7GHGQTFG.html)]]></content>
    </entry>

    
  
  
</search>
