<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[升级Hexo和Next]]></title>
    <url>%2F%E5%8D%87%E7%BA%A7Hexo%E5%92%8CNext%2F</url>
    <content type="text"><![CDATA[一直比较忙，也没有静下心来写博客，今天刚好空闲下来，再次更新了hexo和next的版本。 升级最新版本过程中，多多少会遇到些问题，但基本都逐一解决啦。 文章浏览数归零就不处理啦(￣▽￣)” leancloud安全机制的更改导致，本人又懒得折腾老数据导入等一系列问题，简单粗暴地新建了个应用来统计浏览数 最大的改动，Next主题更换了新仓库Next，之前的仓库不再维护。 贴下博客的最新环境123456789101112131415161718hexo: 3.5.0hexo-cli: 1.1.0hexo-theme-next: 6.4.1os: Darwin 17.7.0 darwin x64http_parser: 2.8.0node: 8.11.4v8: 6.2.414.54uv: 1.19.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.32.0napi: 3openssl: 1.0.2picu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 花时间来折腾博客，无非就是希望自己能够静下心来，断断续续的更新下博客喽~]]></content>
      <categories>
        <category>维护</category>
      </categories>
      <tags>
        <tag>升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《悟空传》摘抄]]></title>
    <url>%2F%E3%80%8A%E6%82%9F%E7%A9%BA%E4%BC%A0%E3%80%8B%E6%91%98%E6%8A%84%2F</url>
    <content type="text"><![CDATA[啊哦，博客貌似荒废挺久了(￣▽￣)”最近又读了一遍《悟空传》，就想着摘抄部分文字。 题外话看了下hexo和next主题的最新版本，吓得我赶紧更新了一遍，但新增的特性只能有时间再慢慢捣鼓啦￣▽￣12345678910111213141516hexo: 3.4.4hexo-cli: 1.0.4os: Darwin 17.3.0 darwin x64http_parser: 2.7.0node: 8.9.3v8: 6.1.534.48uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2nicu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b 心声我要这天，再遮不住我眼，要这地，再埋不了我心，要这众生，都明白我意，要那诸佛，都烟消云散！ 蟠桃园“给我讲个故事吧，你的故事”“……我有什么故事，没有……”“可你在想什么……想从前？”“没有！我没有什么从前！”“不，你在想什么，不准一个人想，我要和你一起想”“咳……想心事还分个人想大家想？你自个爱想什么就想什么吧。”孙悟空翻个身不再理她，闭上眼却又看到了梦中的银色大海。“……我……我想到了，无边的大海，你想到什么？”说这话的是紫霞。“……淹死。”“……我，我还想到在海上飘，在满天的星光下……”“又冷又饿。”“……上岸了，哇，一个从没见过的世界啊，那么多没见过的东西。”“千万别被人捉去。”“到了一座山……菩提山。”“有这座山吗？”“我不管，反正是一座山，有枯藤老树，奇花瑞草，鸟啼与泉声交鸣着。重重的谷壑，风从山中吹来，送来清新凉意，还有隐隐歌声……”“你就开始做梦吗？睁着眼睛也能睡着。”“我……看见你了……”]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多账号SSH配置]]></title>
    <url>%2F%E5%A4%9A%E8%B4%A6%E5%8F%B7SSH%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[如果在同一个git服务器上，你有多个账号（比如你有两个Github账号），就会面临多账号的SSH配置问题。 以下内容是基于MAC电脑，其他操作系统不在本文讨论范畴，但思路一致。 SSHSSH全称Secure Shell，是一种建立在应用层和传输层的安全协议，具有用户认证和数据加密传输等优势。相比于ftp、pop、telnet等明文传送数据的协议，更加安全可靠。由于版权和加密算法等的限制，现在大部分使用的是开放源代码的OpenSSH。 配置文件SSH的配置文件，位于当前用户的根目录下，名字为.ssh隐藏文件夹，在Terminal输入cd ~/.ssh命令即可到该目录（如果提示.ssh文件夹不存在，可以自己创建一个，输入命令cd ~ &amp;&amp; mkdir .ssh即可）。接着输入ls -al即可看到该目录下的所有文件。 如果.ssh目录和该目录的子文件夹递归查找都没有id_rsa、id_rsa.pub文件，说明电脑并没有配置过ssh。 单个SSH key配置大部分情况下，一个git服务器，我们都只有一个账号，优先说明这种状况下的SSH配置。 一、生成密钥1ssh-keygen -t rsa -C "comment" -t 参数，指定生成密钥的算法，常见的有rsa和dsa，默认为rsa（rsa可用于数字签名和加密，而dsa只能用于数字签名，不能加密。与服务器的ssh加密连接用的都是rsa）。该参数可用默认缺省值。 -C 参数，说明文字，一般为相应的git账号，默认为电脑名称。该参数缺省值为电脑名称 该命令可以简写为ssh-keygen即可 生成的密钥默认是存储在.ssh目录下的，一直按回车键即可快速生成key了。 二、添加密钥通过pbcopy命令复制公钥 1pbcopy &lt; ~/.ssh/id_rsa.pub 也可以使用cat ~/.ssh/id_rsa.pub将公钥输出到命令行查看并复制 将复制的公钥粘贴到相应账号的ssh配置项里即可。下面截图为github添加ssh key的示例。 三、连接测试1ssh -T git@github.com 如果出现类似Hi xxxx! You&#39;ve successfully xxx之类的文字，则添加完成。否则，会提示权限不足或一直卡着等其他异常 四、使用ssh登陆验证1git clone [sshUrl] 可以使用 ssh user@ip命令登陆远程主机，eg：远程主机ip为192.168.0.100，存在用户jack，则可以输入ssh jack@192.168.0.100登陆远程主机 下面为我配置好ssh后，拉取自己github某个仓库的代码示例截图 顺便贴个整个过程的截图，我的.ssh目录文件较多，是因为有其他的配置，后面会细说 说明这里说的单个ssh key是指一台git服务器只有一个git账号。也就是说，如果你不仅在github有账号，在coding也有账号，甚至团队内部自己搭建了私有的git服务器等，这些服务器都可以公用同一个ssh key的，绝对没有必要创建多个ssh key。你只需要将相同的ssh公钥添加到相应的服务器的账号设置里即可。如果自己不能添加，可以将公钥发给服务器管理人员，让他帮忙添加也行。 ssh key不仅仅用于git服务器，它还支持远程加密登录和相应的操作。比如，登录云服务器，添加ssh key后，可以免密登录免密登陆的ssh key存放在文件.ssh/authorized_keys里,如果.ssh目录下没有authorized_keys文件可以自己创建该文件，多个授权的ssh key换行即可 多个SSH key配置所有通过ssh验证过的IP（域名）都会被系统自动添加到.ssh目录下的known_hosts文件里，下次再次连接该IP（域名）时，优先读取该文件里的SSH key。 假如有这样的场景：用户A在Github有一个自己私人账号，在电脑上创建并添加过ssh key。某一天，公司要求A再次创建一个公司账号，然后用公司账号拉取项目。 面临的问题：同一台服务器，不同用户的ssh key是不可能相同的。所以，A之前的ssh key是没法用于公司账号的，必须重新为公司账号创建一个新的ssh key。 那么，这个新创建的ssh key存放在哪？通过ssh认证连接时，怎么向服务器发送正确的私钥来验证用户的正确性？ 如果你之前通过http/https的方式拉取过github代码，输入账号密码成功后，github服务器会将它的公钥发给你电脑，电脑会将该公钥存储在.ssh目录下的known_hosts文件里。之后再次通过http获取/上传代码，就可以免密直接拉取/上传代码了。 如果A不想再次创建ssh key，尝试通过http的方式拉取代码，会直接报错（没有权限）。那是因为known_hosts文件里有A自己的私有账号信息，系统默认匹配到相同IP（域名），将A的私有账号发给服务器了，当然会无权限喽。 这个时候，A可以删除known_hosts文件里github对应的那一行记录，然后通过http/https认证。但这样做，想要切换回自己的私有账号，又要再次删除known_hosts文件对应的内容。如此反复，太麻烦。 有没有更简单的方式呢？当然喽！通过创建配置文件的方式。 创建的config文件的内容格式为 123456Host [shortName] HostName [domain] PreferredAuthentications publickey IdentityFile [private keyPath] User [user] Port [port] shortName 简称，因为相同域名下有多个账号，所以简称需要不一样才能区分。通过ssh拉取/上传代码时，需要用相应的shortName替换掉ssh地址的域名，其它保持不变，才能保证ssh调用对应的私钥去登陆验证。 domain 对应的服务器域名(IP) private keyPath 私钥绝对路径 user 用户名。服务器的用户名，不是你的用户名。eg：大部分的git服务器用户名都为git port 端口号，默认为22 比如，我在git.coding.net上有两个账号。.ssh目录下地文件结构如下： 其中config文件内容为： 12345678910111213Host coding1 HostName git.coding.net PreferredAuthentications publickey IdentityFile ~/.ssh/coding1/id_rsa User git # Port 22Host coding2 HostName git.coding.net PreferredAuthentications publickey IdentityFile ~/.ssh/coding2/id_rsa # User git # Port 22 具体ssh key怎么生成，参考前面单个ssh key的过程。提醒下，生成ssh key时是可以指定位置存储的。(指定位置时默认是相对当前路径的，也可以填写完整的绝对路径) 将coding1和coding2对用的公钥分别添加到对应的账号设置里后，验证是否成功，和之前单个ssh key有差别。之前是直接输入 ssh -T git@git.coding.net,现在则是通过简称映射对应的域名和私钥。eg：ssh -T git@coding2 由于coding1配置的User为git，所以测试时，可以简单输入ssh -T coding1即可。而coding2没有设置User（注释掉了），则必须输入ssh -T git@coding2 配置好多个ssh key后，拉取代码时，需要将ssh的地址做细微修改，才能用正确的用户去登陆验证。就是将对应的域名（IP）换成config文件里配置的shortName即可。 原本的ssh地址为`git@git.coding.net:momoer/DemoForSSH.git，需要修改为git@coding2:momoer/DemoForSSH.git再取拉取即可。如果配置了User项，ssh地址可以简写为coding2:momoer/DemoForSSH.git` 友情提示： 通过ssh拉取的代码，如果之前在~/.gitconfig文件里配置过user信息，而又不想用全局的user信息，可以在当前工程里的.git/config文件里配置user信息，以便查看commit记录等。 顺便贴个我的DemoForSSH仓库的git配置文件12345678910111213141516[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[user] name = zhenzhaoyang email = zzyhappyzzy@163.com[remote &quot;origin&quot;] url = git@coding2:momoer/DemoForSSH.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master 嗯，大概就这些吧。That’s All ~]]></content>
      <categories>
        <category>版本管理工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对https的一些理解]]></title>
    <url>%2F%E5%AF%B9https%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[随着互联网的普及，不管是PC端的web，还是移动端的app，甚至智能家居等，绝大部分的通信都是依靠http协议传输数据，但http协议只负责传递信息，并不能保证信息的安全性和可靠性。 信息安全简单来说，信息安全就是为了保证传递的信息只能被正确的人接收和识别，并且接收方能够验证信息是否被篡改，最终能够正确识别收到的信息。 信息传输的流程：发送方 -&gt; 传输环境（发送消息） -&gt; 接收方，为了保证安全性，一般在以下方面做尝试： 数据加密/解密 专用网络 数据真实性验证 有些人可能认为信息安全对我有什么用？根本就没必要关心这些。但真的是这样么？互联网世界，比现实的世界更复杂，到处都可能是陷阱。作为普通的网民，如果你的浏览记录能够被人随意查看，或者被强行插入广告，甚至弹出恶意挂马的链接。。。你会作何感想？作为服务提供方，客户和你们的信息传递被人随意监听，甚至拦截更改数据，你又作何感想？ 不管怎么说，服务提供方有义务为用户提供安全的通信机制，来保护用户的隐私和安全。在此基础上，网景公司Netscape提出了SSLSecure Sockets Layer协议，之后，国际组织IETF在SSL的基础上，制定出标准化的TLSTransport Layer Security协议，不管是SSL还是TLS，都可用于其他的网络协议，如：FTP、SMTP、NNTP、XMPP等。 HTTPSHTTPS，全称Hyper Text Transport Protocol Secure，又被称为HTTP over TLS或者HTTP Secure，主要目的是在不安全的网络通信环境上建立安全的通信机制，尽量保证信息的安全性和正确性。 SSL/TLS采用非对称加密算法，简单的说，就是公开公钥，保留私钥。通常来说，消息经过公钥加密后，只有持有私钥才能解密，得到最原始的可读消息。反过来，公钥加密的消息，只有通过私钥解密才能还原真实信息。整个过程就是常说的”数字签名”。 数字签名的示意图如下： 但是单纯的数字签名有漏洞，别人可能伪造公钥，诱导用户用假的公钥加密信息，这样它们就能监听你的任意消息。为了避免这种状况，证书颁发机构CA应运而生，它的作用类似公证人，将你的公钥和其它相关的信息，用CA自己的公钥加密后发给你，你再把证书发给用户作为公钥即可证明”你的公钥确实是你的公钥”，而不是别人伪造的。 一般来说，操作系统和浏览器都内嵌了受信任的证书机构，用户无需额外操作。理论上来说，公认的证书颁发机构CA的私钥是不可能泄露的，所以安全方面就不用担心了。但是，证书却是任何人都可以制作和颁发的，所以为了避免上述提到的：伪造公钥的问题。对于用户自己下载的证书，特别是根证书，不要轻易将它加到受信任的证书列表里，可以有效防止个人信息被监听。 http vs https的简要图： mac电脑直接打开Keychain（钥匙串）即可管理证书windows用户，参考https://technet.microsoft.com/zh-cn/library/cc754841(v=ws.11).aspx 注意https只能提高用户和服务器之间通信的安全性和可信性，并不能提高服务器的安全性。所以，如果服务器自己没有相应的安全防护机制，用户的敏感信息还是有泄露的可能。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
        <tag>ssl/tls</tag>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS证书的那些事]]></title>
    <url>%2FiOS%E8%AF%81%E4%B9%A6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[提到iOS开发，肯定少不了与证书打交道。本文主要记录下个人对证书的一些理解，希望大家少踩坑。 概要虽然苹果整个生态链是封闭未开源的，但安全性在业内绝对靠前。证书，也可以说是数字签名，只是整个生态链安全性中的一环而已。无论是底层系统的设计，上架审核，还是对https的推行，以及近期火热的JSPatch等动态更新问题，都可以看出苹果还是很重视生态链的稳定和安全。 在这里，我并不会告诉你证书生成的具体流程，因为网上相关资料很多。 要想对app进行签名，需要拥有苹果开发者账号（个人或企业），在开发者中心创建根证书（开发development和生产production），然后在根证书的基础上，不同的应用application根据bundleId不一样，创建相应的推送证书、开发证书等一系列相关的证书。 如果发布应用，需要下载Apple全球开发者证书AppleWWDRCA.cer 苹果的证书，采用非对称加密算法，有公钥和私钥，通常我们所说的CSRCertificate Signing Request文件就是用来创建私钥的。所以，为了便于后续私钥的管理，建议所有证书用相同的CSR文件，CSR文件一直保留 当然，不同的证书可以有不同的CSR文件，只要你自己不嫌麻烦CSR文件是用KeyChain生成的(Keychain Access &gt; Certificate Assistant &gt; Request a Certificate From a Certificate Authority)。注意不要填写CA，邮箱最好填AppleId账号，名字看着取，最后选择存储到磁盘即可谁电脑创建的证书，需要将证书导出（KeyChain找到相应的证书，可以将展开的两个都选中，也就是公钥和私钥都选中，右键导出为p12文件），传给没有私钥的开发 应用支持的功能（GameCenter、PushNotification、InAppPurchase等），在开发者中心的Identifiers（即app IDs）里随时编辑的。 比如开始某app没有推送，后期接入推送，需要在app IDs里找到相应的bundleId开启PushNotification功能，然后生成推送证书 证书过期苹果的证书一般有效期是一年，即将过期时，开发者需要对证书进行更新，整个过程类似新建证书 对于即将过期的证书，并不需要撤销Revoke。如果一定要撤销，最好在新证书都搞定后，服务器也更新了相应的推送证书后，再操作（保证不影响线上产品）推送证书是和app的bundleId绑定的，服务器只需更新最新的推送证书即可，之前的版本也可以收到推送，无需重新发包企业证书等非appstore的证书(InHouse/AdHoc等)签发的安装包，一旦过期，必须用最新的证书重新打包，发布新版本(过期证书签发的包无法使用)。appstore证书签发的包，一旦过期，已存在的产品不受影响（注意：如果推送证书过期，还是必须更新推送证书的） 模拟推送将推送证书p12转换为pem文件，可以使用下面命令1openssl pkcs12 -in cert.p12 -out apple_push_notification.pem -nodes -clcerts 可以使用php、ruby、python、nodeJ等各种语言实现。 推荐个ruby写的推送模拟：Houston]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>证书</tag>
        <tag>certificate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习正则表达式]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一直感觉正则表达式很神奇，非常强大，但并没有系统学习过，今天抽空过一遍，希望能够彻底掌握它 简介正则表达式在处理文本信息时非常有用，不限于代码、日志文件、文档等。在开始学习正则之前，需要有这种概念：任何文本都是由单个字符组成。 语法简单匹配 abcdefg、abcde、abc这三个字符串，用正则abc可以匹配前面三个串的abc字段abc123xyz、define”123”、var g=123，用正则123可以匹配三个公共的123数字 简单语法 \d 匹配任何0~9的数字；\D匹配任意非数字0~9的字符. 表示通配符，可以匹配任意字符。如果要匹配.，可以加入转义符\. Task Text Match cat. Match 896. Match ?=+. Skip abc1 上面的例子，正则...\.匹配前三个，最后一个不匹配 匹配特定的字符，使用[] Task Text Match can Match man Match fan Skip dan Skip ran Skip pan 上面的例子，需要匹配前三个，后三个不匹配，可用正则[cmf]an。[cmf]表示只匹配cmf之中的任意一个。 剔除特定字符,使用[^…] Task Text Match hog Match dog Skip bog 上面的例子，需要匹配前练个，最后一个不匹配，可用正则[^b]og，当然也可以用前面的匹配特定字符[hd]og 连续字符,使用-如果要匹配26个小写字母，难道我们要吧26个字母全部列出来么？当然可以，但太二了不是么。正则表达式用-表示连续的字符。如0-6相当于[0123456] Task Text Match Ana Match Bob Match Cpc Skip aax Skip bby Skip ccz 上面的例子，匹配前三个，后三个不匹配，可用正则[A-c][n-p][a-c] 注意，大写和小写字母是不同的字符，需要分开处理\w相当于[A-Za-z0-9_]，\W相当于[^A-Za-z0-9_] 字符个数的匹配,使用{}前面提到的额匹配都是单个字符的匹配，如果需要匹配3个数字，你也许会写成\d\d\d，但实际上有更好的写法，比如\d{3}。正则甚至支持范围，如a{1,3}表示最少有1个a，最多3个a。 Task Text Match wazzzzzup Match wazzzup Skip wazup 上面的例子，前两个匹配，最后一个不匹配，可用正则表达式waz{3,5}up 字符任意个数的匹配 *表示大于等于0个 +表示大于等于1个 比如，\d*表示任意个数字，但是\d+则表示最少要有一个数字 Task Text Match aaaabcc Match aabbbbc Match aacc Skip a 上面的例子，前三个匹配，最后一个不匹配，可用正则aa+b*c+ 标记某个字符可选，使用?由于？修饰的字符为可选，所以正则ab?c可以匹配abc或者ac。 Task Text Match 1 file found? Match 2 files found? Match 24 files found? Skip No files found. 上面的例子，前三个匹配，最后一个不匹配，可用正则\d+ files? found\? 空格、换行、对齐等字符空格&emsp;制表符tab(\t) 换行(\n) 回车(\r)。可以用\s来表示前面任意的空白符。同理，\S与\s相反，即各种空白符之外的字符。 Task Text Match 1.&emsp;abc Match 2.&emsp;&emsp;&emsp;&emsp;abc Match 3.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;abc Skip 4.abc 上面的例子，前三个匹配，最后一个不匹配，可用正则\d\.\s+abc 开始^和结束$需要注意的是，这里的开始^和例外[^...]的意义是不同的。假如需要验证用户的输入是否为5-12位数字组成的QQ号码，可以用^\d{5,12}$。 Task Text Match Mission: successful Skip Last Mission: unsuccessful Skip Next Mission: successful upon capture of target 上面的例子，第一个匹配，后两个不匹配，可用正则^Mission: successful$ 匹配并分组(…)正则表达式不仅仅可以用来匹配，还可以将匹配的结果进行分组group。比如，我们可以用正则表达式^(IMG\d+\.png)$找出所有照片,但是如果我们只需要照片名，不需要后缀名png呢，你会怎么做？这个时候可以用^(IMG\d+)\.png$ Task Text Capture file_record_transcript.pdf Capture file_07241999.pdf Skip testfile_fake.pdf.tmp 上面的例子，可用正则^(file.+)\.pdf$ 当然，分组还支持嵌套，用于更复杂的多重分组。如下，匹配日期并且列出年份 Task Text Capture Jan 1987 Capture May 1969 Capture Aug 2011 上面的例子，可用正则(\w+ (\d{4})) 条件匹配(…|…)假如你让别人给你带早餐，但你又不确定早餐店还剩下什么，这时候你会给别人几个备选项，在正则里可以用(..|..)来表示。如Buy more (milk|bread|juice) Task Text Match I love cats Match I love dogs Skip I love logs Skip I love cogs 上面的例子，可用正则I love (cats|dogs) 字符边界通常用\b表示字符的边界，与之相对的\B。现有字符串Chapter 1,可以用正则ter\b匹配得到ter，注意\b的位置，如果正则写成\bter则无匹配结果 练习匹配浮点数 Task Text Match 3.14529 Match -255.34 Match 128 Match 1.9e10 Match 123,340.00 Skip 720p 上面的例子，可用正则表达式^-?\d+(,\d+)*(\.\d+(e\d+)?)?$ 匹配图片 Task Text Skip .bash_profile Skip workspace.doc Capture img0912.jpg Capture updated_img0912.png Skip documentation.html Capture favicon.gif Skip img0912.jpg.tmp Skip access.lock 上面的例子，可用正则表达式(\w+)\.(jpg|png|gif)$ 说明本文参考链接regexone 文中的正则表达式只是示例，要达到同样的结果，正则表达式可能有多种写法]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>regex</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈MVC和MVVM]]></title>
    <url>%2F%E8%B0%88%E8%B0%88MVC%E5%92%8CMVVM%2F</url>
    <content type="text"><![CDATA[在iOS开发的过程中，你肯定听说过MVC下面记录下个人对这种设计模式的理解，顺便谈谈衍生的MVVM设计模式。 前言不管采用哪种设计模式，都是为了程序结构更清晰，便于后续扩展、复用，从某方面来说，程序员的最大敌人就是需求的不断更新和增加，而我们要做的就是：以不变应万变。这就需要相应的设计模式了，否则，我们的程序只会越来越庞大，到处都是冗余代码，无法维护和扩展，最终谁也拿它没辙。 换句话说，编码的原则是DRYDon&#39;t repeat yourself，如果你发现项目里有很多重复/类似的代码、某个类特别庞大、改需求特别痛苦、新项目完全从零起步，那我们就必须思考问题出在哪，并用相应的设计模式来重构代码，避免发生上述的状况 Model-View-Controller Model模型层，封装数据结构和相应的逻辑操作等。不能和视图层有直接的通信。用户在视图层的操作，通过控制层更新相应的模型层，然后通知控制层更新视图层界面。 View视图层是展现给用户看的，知道怎样布局，响应用户的操作。通常视图层需要和模型层解耦。模型层的改变，通过控制层来更新视图层的显示。 Controller控制层协调单个或多个模型和视图的关联，分配任务及管理app的生命周期等。 MVC模式里，Model、View和Controller相互独立，互不影响。通常为了实现需求，而没有将Controller进行拆分，导致Controller控制的状态过多，后期很难维护。需要将协调视图View和模型Model无关的代码抽出去，比如网络请求、数据库的读写等可以放到单独的模型Model里，Controller只需接受Model的更改并通知视图View更新即可。不同层不要相互引用，降低耦合。如：Model层不要直接引用View层，最好只引用同类别的Model MVC在IOS开发中的不足开发的过程中，由于Controller和View的紧耦合，导致MVC的三部分拆分并不完全独立，以及单元测试难以覆盖等问题。 Model-View-ViewModel 对比MVC，可以发现他们很相似，视图View和数据Model并没有直接通信，都要通过中间控制器协调（Controller或ViewModel）。那么在IOS开发中，ViewController和View都被划分到MVVM的视图层，Model还是模型层，ViewModel能主动调用Model的api对Model进行更改，也能在Model更改时对自身进行更新，然后通过View和ViewModel之间的绑定，对View进行更新。 View和ViewModel的绑定，常见的有两种方法 KVO 如Bond 函数式响应编程 如ReactiveCocoa]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MMVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017新的起点]]></title>
    <url>%2F2017%E6%96%B0%E7%9A%84%E8%B5%B7%E7%82%B9%2F</url>
    <content type="text"><![CDATA[博客从搭建到现在，中途荒废了好长一段时间，借口确实一大把，但是说到底就是懒呗(⊙﹏⊙) 2016过去一年，生活方面，进步确实挺小，希望今年可以改进。工作方面么，不在局限于Objective-C/Swift，也接触了一些前端知识，比如H5、Weex、Vue、React、JS、Webpack等一系列web前端和跨平台开发相关的知识点。可惜，除了参加大学同学的婚礼时去了趟杭州，就没去外地游玩过。 2017过去的就让它过去，新的一年里，还是有不少事情是必须完成的。别人的目标都是以亿为单位，我的目标藏在心里就好 (•̀ᴗ•́)。小目标还是可以贴几个的： 每个月最少读一本书 每个月最少发布两篇博客 调整作息时间，每天晚上23：00之前睡觉 小尾巴山重水复疑无路，柳暗花明又一村。Go，Go，Go！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios学习资料]]></title>
    <url>%2Fios%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[本文主要记录下常用的IOS学习资源 网站列表文章 英文 objc.io iOS Goodies NSHipster Ray Wenderlich Apple’s Swift Blog AppCoda IOSDevWeekly Medium Ry’s Cocoa Tutorial NSScreencast Use Your Loaf OleBegemann little bites of cocoa Toptal 中文 objc.io Cocoa China Code4App 文档 Apple Developer 社区 Stackoverflow 源码 Github 算法 Codefights 视频 WWDC视频 Stanford iTunes video 图标 The Noun Project 工具 Docker 如果你使用Docker，可以试试Kitematic和Captain Zeplin GitKraken 说明 欢迎各路大神评论，持续更新中。。。]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码诊断Clang Diagnostics]]></title>
    <url>%2F%E4%BB%A3%E7%A0%81%E8%AF%8A%E6%96%ADClang-Diagnostics%2F</url>
    <content type="text"><![CDATA[注意本文转载自http://nshipster.cn/clang-diagnostics/ 概要诊断结合了逻辑与分析来得出一个结论。这是最纯粹的科学和工程学，也是人类最有力的推理。在医学界，诊断是通过实验室样本做后盾的本能来判断。而对于工业制造，则是通过在统计和方向都等同应用来诊断产品故障。 对于我们开发者来说，我们通过代码通知后续代码的生产，创建了一个在过去半个世纪里呈几何级数发展的技术的正反馈循环。尤其对于我们的 Objective-C 开发者来说，最有效的诊断来自 Clang。 Clang 是 C / Objective-C 的前端的 LLVM 编译器。它对 Objective-C 的语义和语法有着深刻的理解，而且更重要的原因是现在 Objective-C 已经是这样一个有能力的语言了。 当你在 XCode 中运行 “Build &amp; Analyze” (⌘⇧B) 后得到的惊人结果是 Clang 的更细腻，更深沉一面的功能：它的代码诊断。 在我们关于 #pragma 文章中，我们打趣的说： 资深提示：尝试设置 -Weverything 标志，并在你的编译设置中勾选上 “Treat Warnings as Errors”。这将在 Xcode 中开启困难模式。 现在，我们支持这个建议，并鼓励其他开发者更严肃的对待编译警告。然而，也有一些情况下，你和 Clang 会陷入僵局。例如，考虑以下 switch 语句：123456789switch (style) &#123; case UITableViewCellStyleDefault: case UITableViewCellStyleValue1: case UITableViewCellStyleValue2: case UITableViewCellStyleSubtitle: // ... default: return;&#125; 当启用这些标志后，Clang 会警告说 “default label in switch which covers all enumeration values”。然而，放大到一个更大的背景下，如果我们 知道 style 是（不管怎样）从外部来源的描述（如JSON资源），允许无约束的 NSInteger 值，则 default 情况是必要的保障。坚持这个必然性的唯一方法就是使用 #pragma 暂时忽略警告标志： push &amp; pop 用于保存和恢复编译器的状态，类似 Core Graphics 或 OpenGL 上下文。 123456789101112#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wcovered-switch-default"switch (style) &#123; case UITableViewCellStyleDefault: case UITableViewCellStyleValue1: case UITableViewCellStyleValue2: case UITableViewCellStyleSubtitle: // ... default: return;&#125;#pragma clang diagnostic pop 而且，怎么强调都不为过，Clang 至少在 99％ 的情况下都是对的。事实上修正一个分析警告 最好的 办法就是忽略它。使用 #pragma clang diagnostic ignored 作为最后的方法 最后，附上一份（基本上）全面的 Clang 警告综合列表，可以在这里找到：http://fuckingclangwarnings.com/ Clang警告列表的源码https://github.com/NSHipster/fuckingclangwarnings.com]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>Clang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据打包和解包入门篇]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[数据的传输和获取，通常会涉及到数据的压缩和解压等操作如果现在有这么个需求 1、从服务器下载的图片，根据图片的二进制数据流决定图片的格式，你会怎么办? (数据截取)2、需要将用户每天24小时的生活状态传到服务器，然后可以按年/月/周/天取出并统计、展示等，你会怎么办？(字节数组) 对于上面的问题，我们就必须考虑数据结构，并实现压缩和解压等操作下面给予一个简单的示例，希望有所启示12345678910111213141516171819202122232425 //打包 int tmpSize = 10; Byte *tmpBuffer = malloc(sizeof(Byte)*tmpSize); for (int i = 0;i&lt;tmpSize;i++) &#123; tmpBuffer[i] = i; &#125; NSData *data = [[NSData alloc] initWithBytes:tmpBuffer length:tmpSize]; //解包 NSInteger length = data.length; Byte *parseBuffer = malloc(sizeof(Byte) * length); [data getBytes:parseBuffer length:length];// [data getBytes:parseBuffer range:NSMakeRange(0, length)]; Byte *p = parseBuffer; Byte *q = parseBuffer+length; while (p&lt;q) &#123; int parseValue = *p; NSLog(@"parse value is %d",parseValue); ++p; &#125; free(tmpBuffer); free(parseBuffer);]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>打包/解包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJS安装和更新]]></title>
    <url>%2FnodeJS%E5%AE%89%E8%A3%85%E5%92%8C%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[说明本文只记录macOSX系统，其它系统参考官网 安装HomeBrew安装12/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;brew install node 安装包官网下载最新安装包即可 更新HomeBrew安装的node1brew upgrade node 其它方式安装的node使用node的包管理工具n 123sudo npm cache clean -fsudo npm install -g nsudo n stable n简要说明sudo n version 可以安装指定node版本，如sudo n v4.4.5（如果电脑没有指定的版本，则会自动安装并将node切换到该版本；如果安装了，则直接切换到指定的版本）。n list可以查看所有的node版本n可以查看已安装的node版本 卸载 HomeBrew安装的brew uninstall node n安装的sudo n rm version shell脚本卸载1234567lsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom \| while read i; do sudo rm /usr/local/$&#123;i&#125;donesudo rm -rf /usr/local/lib/node \ /usr/local/lib/node_modules \ /var/db/receipts/org.nodejs.*]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios10简介]]></title>
    <url>%2Fios10%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[ios10新特性简介 概要个人感觉ios10的主要特性就是：开放、智能、便捷。 支持的设备 新特性短信iMessage 支持手写输入自定义消息框样式发送的内容可以选择先隐藏，接收者点击具体内容后才加载出来，营造惊喜模式支持自定义快捷回复和简单明了的点赞之类的快速交互表情支持类似微信生日快乐之类的动画效果支持文字和emoji转换开放第三方接口（类似微信的安装第三方聊天表情等) Siri 开放siri语音识别和处理等接口第三方app与siri的结合更智能。比如通过siri直接向微信里的特定好友发消息等。 照片photo 快捷搜索功能智能分类 地图 从ios7开始，苹果就致力于地图app功能的完善，但国内基本用不到。。。开放第三方接口。 通知 收到通知后，不用解锁，进入相应的app，用户可以直接处理消息。通知的外观也不再一成不变，第三方app可以自动以通知外观 智能家居 用户可以在桌面更智能便捷的控制家居等 电话 微信等的语音通话，可以直接调用系统的电话界面等来电识别等(如骚扰电话) 音乐、新闻 国内基本无用。。。 支付applePay 类似支付宝等的网页扫码支付 3D Touch 在桌面上的app图标上就可以使用3dTouch功能，而不用打开相应的app。 Widget 锁屏状态下，可以重新设计widget的外观]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>WWDC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios设备信息]]></title>
    <url>%2Fios%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[本文列举了常见的apple设备基本信息，主要包括ARM/Pixes/DPI/Size等信息 iPhone name hw.model ARM Pixes Points Size DPI/PPI iPhone 4 iPhone3,1iPhone3,2iPhone3,3 armv7 640x960 320x480 3.5英寸(89mm) 326 iPhone 4S iPhone4,1 armv7 640x960 320x480 3.5英寸(89mm) 326 iPhone 5 iPhone5,1iPhone5,2 armv7s 640x1136 320x568 4.0英寸(100mm) 326 iPhone 5C iPhone5,3iPhone5,4 armv7s 640x1136 320x568 4.0英寸(100mm) 326 iPhone 5S iPhone6,1iPhone6,2 arm64 640x1136 320x568 4.0英寸(100mm) 326 iPhone 6 Plus iPhone7,1 arm64 1080x1920 414x736 5.5英寸(140mm) 401 iPhone 6 iPhone7,2 arm64 750x1334 375x667 4.7英寸(120mm) 326 iPhone 6S iPhone8,1 arm64 750x1334 375x667 4.7英寸(120mm) 326 iPhone 6S Plus iPhone8,2 arm64 1080x1920 414x736 5.5英寸(140mm) 401 iPhone SE iPhone8,4 arm64 640x1136 320x568 4.0英寸(100mm) 326 iPad name hw.model ARM Pixes Points Size DPI/PPI iPad 1 iPad1,1 armv7 1024x768 1024x768 9.7英寸(250mm) 132 iPad 2 iPad2,1iPad2,2iPad2,3iPad2,4 armv7 1024x768 1024x768 9.7英寸(250mm) 132 iPad 3 iPad3,1iPad3,2iPad3,3 armv7 2048x1536 1024x768 9.7英寸(250mm) 264 iPad 4 iPad3,4iPad3,5iPad3,6 armv7s 2048x1536 1024x768 9.7英寸(250mm) 264 iPad Air 1 iPad4,1iPad4,2iPad4,3 arm64 2048x1536 1024x768 9.7英寸(250mm) 264 iPad Air 2 iPad5,3iPad5,4 arm64 2048x1536 1024x768 9.7英寸(250mm) 264 iPad Mini 1 iPad2,5iPad2,6iPad2,7 armv7 1024x768 1024x768 7.9英寸(200mm) 163 iPad Mini 2 iPad4,4iPad4,5iPad4,6 arm64 2048x1536 1024x768 7.9英寸(200mm) 326 iPad Mini 3 iPad4,7iPad4,8iPad4,9 arm64 2048x1536 1024x768 7.9英寸(200mm) 326 iPad Mini 4 iPad5,1iPad5,2 arm64 2048x1536 1024x768 7.9英寸(200mm) 326 iPad Pro iPad6,7iPad6,8 arm64 2732x2048 1356x1024 12.9英寸(330mm) 264 iPad Pro iPad6,3iPad6,4 arm64 2048x1536 1024x768 9.7英寸(250mm) 264 iPod name hw.model ARM Pixes Points Size DPI/PPI iPod 1 iPod1,1 armv6 320x480 320x480 3.5英寸(89mm) 163 iPod 2 iPod2,1 armv6 320x480 320x480 3.5英寸(89mm) 163 iPod 3 iPod3,1 armv7 320x480 320x480 3.5英寸(89mm) 163 iPod 4 iPod4,1 armv7 640x960 320x480 3.5英寸(89mm) 326 iPod 5 iPod5,1 armv7 640x1136 320x568 4.0英寸(100mm) 326 iPod 6 iPod7,1 arm64 640x1136 320x568 4.0英寸(100mm) 326 iWatch name hw.model ARM Pixes Points Size DPI/PPI Apple Watch Watch1,1Watch1,2 armv7k 272x340 136x170 1.337英寸(33.96mm) 326 Apple Watch Watch1,1Watch1,2 armv7k 312x390 156x195 1.534英寸(38.96mm) 326]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins自动化集成]]></title>
    <url>%2FJenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[说明Jenkins很强大，本文主要记录Jenkins用于iOS自动打包。 步骤Jenkins官网下载最新安装包 如果下载太慢，可以使用我的备份Jenkins1.651.2 双击下载的pkg文件，安装Jenkins。安装完成后，在浏览器输入http://localhost:8080可以看到Jenkins的页面 提升jenkins的用户权限为管理员12sudo dseditgroup -o edit -a jenkins -t user adminsudo dscl . append /Groups/_developer GroupMembership jenkins (可选) 补全Jenkins用户的信息 打开系统偏好设置，选择用户与群组,输入密码解锁。选择没有名字的那个用户，重新设置下密码，然后右键-&gt;高级选项，补全名字 从当前用户切换到jenkins。使用命令su -l 用户名(也可以重启电脑，选择jenkins用户登录，然后安装相关的证书。下面讲述的是命令行操作)1su -l jenkins 为了方便从git等仓库拉取代码，生成SSH。(该过程最好全部默认，即一直按回车即可)1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; //邮箱为对应git仓库的用户名 使用cat命令查看SSH并复制出来，然后在相应的git仓库配置SSH即可。 由于我是命令行切换的用户，直接pbcopy是无用的，只能打印出来手动复制了。如果是登录时选择的Jenkins，可以使用pbcopy &gt; ~/.ssh/id_rsa.pub复制SSH 1cat ~/.ssh/id_rsa.pub 创建证书文件夹MobileDevice。将证书*.mobileprovision复制到Provisioning Profiles文件夹下1234cd /Users/Shared/Jenkins/Librarymkdir MobileDevicecd MobileDevicemkdir &apos;Provisioning Profile&apos; 配置Jenkins 安全配置 插件配置(默认没有git插件，需要自己安装) XCode的工程配置里，Code Signing需要配置好相应的证书给个参考的shell配置（注：工程采用了cocoapods管理第三方库） 重点在xcodebuild、xcrun命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#xxx为具体工程名，记得替换掉，目录结构也可能不一致，需微调echo "start execute shell"echo $(pwd)CURRENT_DIR=$(pwd)GIT_VER_NUM=$(git rev-list head | sort | wc -l)#GIT_COMMIT_ID=$(git rev-list head | head -1)#echo "git version:$&#123;GIT_VER_NUM&#125;,commit id $&#123;GIT_COMMIT_ID&#125;"PRO_DIR="$&#123;CURRENT_DIR&#125;/xxx"cd $&#123;PRO_DIR&#125;WORKSPACE_DIR="$&#123;PRO_DIR&#125;/*.xcworkspace"export LC_ALL="en_US.UTF-8"/usr/local/bin/pod installPLIST_DIR="$&#123;PRO_DIR&#125;/xxx/xxx-Info.plist"echo "plist dir is $PLIST_DIR"#打包前修改build号/usr/libexec/PlistBuddy -c "Set CFBundleVersion $&#123;GIT_VER_NUM&#125;" $&#123;PLIST_DIR&#125;APP_VERSION=$(/usr/libexec/PlistBuddy -c "print CFBundleVersion" $&#123;PLIST_DIR&#125;)APP_SHORT_VERSION=$(/usr/libexec/PlistBuddy -c "print CFBundleShortVersionString" $&#123;PLIST_DIR&#125;)echo "version $&#123;APP_VERSION&#125; build $&#123;APP_SHORT_VERSION&#125;"RELEASE_IPA_DIR=$&#123;CURRENT_DIR&#125;/IOS#date +%Y%m%d%H%M%SBUILD_DATE=$(date +%Y%m%d%H%M)IPA_NAME="Release_$&#123;BUILD_DATE&#125;_xxx_V$&#123;APP_SHORT_VERSION&#125;.$&#123;APP_VERSION&#125;.ipa"DSYM_NAME="Release_$&#123;BUILD_DATE&#125;_xxx_V$&#123;APP_SHORT_VERSION&#125;.$&#123;APP_VERSION&#125;.app.dSYM"if [ -d $&#123;RELEASE_IPA_DIR&#125; ]; thenecho "$&#123;RELEASE_IPA_DIR&#125; exist"rm -rf $&#123;RELEASE_IPA_DIR&#125;/*.ipaelseecho "$&#123;RELEASE_IPA_DIR&#125; do not exist, need create dir"mkdir $&#123;RELEASE_IPA_DIR&#125;fiCONFIGURATION_INHOUSE="Release"SCHEME="xxx"BUILD_APP_DIR="$&#123;PRO_DIR&#125;/Build/Products/$&#123;CONFIGURATION_INHOUSE&#125;-iphoneos"xcodebuild clean -workspace $WORKSPACE_DIR -scheme "$&#123;SCHEME&#125;" -configuration "$&#123;CONFIGURATION_INHOUSE&#125;" -derivedDataPath "$&#123;PRO_DIR&#125;"xcodebuild -workspace $WORKSPACE_DIR -scheme "$&#123;SCHEME&#125;" -configuration "$&#123;CONFIGURATION_INHOUSE&#125;" -derivedDataPath "$&#123;PRO_DIR&#125;"xcrun -sdk iphoneos PackageApplication -v $&#123;BUILD_APP_DIR&#125;/*.app -o $&#123;RELEASE_IPA_DIR&#125;/$&#123;IPA_NAME&#125;OUTDIR="/Users/Shared/Jenkins/IOS"BUILD_DATE=$(date +%Y%m%d)OUT_IPA_DIR=$&#123;SEAFILEDIR&#125;/$&#123;BUILD_DATE&#125;if [ -d $&#123;OUT_IPA_DIR&#125; ]; thenecho "$&#123;OUT_IPA_DIR&#125; exist"elseecho "$&#123;OUT_IPA_DIR&#125; do not exist, need create dir"mkdir $&#123;OUT_IPA_DIR&#125;fimv $&#123;RELEASE_IPA_DIR&#125;/$&#123;IPA_NAME&#125; $&#123;OUT_IPA_DIR&#125;mv $&#123;BUILD_APP_DIR&#125;/*.dSYM $&#123;OUT_IPA_DIR&#125;/$&#123;DSYM_NAME&#125;###该处为非pod管理的工程关键代码#BUILD_APP_DIR=$&#123;CURRENT_DIR&#125;/xxx/build/$&#123;CONFIGURATION_INHOUSE&#125;-iphoneos/*.app#xcodebuild clean -project $PRO_DIR -target $&#123;TARGET_NAME&#125; -configuration $&#123;CONFIGURATION_INHOUSE&#125;#xcodebuild -project $PRO_DIR -target $&#123;TARGET_NAME&#125; -configuration $&#123;CONFIGURATION_INHOUSE&#125;#xcrun -sdk iphoneos PackageApplication -v $&#123;BUILD_APP_DIR&#125; -o $&#123;OUT_IPA_DIR&#125;/$&#123;IPA_NAME&#125; 升级前段时间将XCode升级到8.3之后，发现之前那的打包脚本被弃用了，顺便更新下脚本，思路不变，使用export命令生成ipa文件。使用export命令之前，需要在工程目录添加plist文件，描述打包等相关信息。给个appstore包的plist文件例子。 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;app-store&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; inHouse证书的例子，只是将method的value改为enterprise即可。还有其他的值：ad-hoc，development等。上面的plist文件还可以添加其他的键值对，但用默认值即可。 Xcode9.0后，archive需要指明描述文件，也就是上面的plist文件需要新增provisioningProfiles键值对。需要将provisioningProfiles值的yourAppBundleId和对应的yourAppProvisioningProfileName改为你app的值 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;enterprise&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;yourAppBundleId&lt;/key&gt; &lt;string&gt;yourAppProvisioningProfileName&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt; 升级后的打包核心脚本，其中packageRelease.plist的内容与上面的例子类似 普通的工程 123456789101112CURRENT_DIR=$(pwd)PRO_DIR = $&#123;CURRENT_DIR&#125;XC_PROJECT_DIR="$&#123;PRO_DIR&#125;/*.xcodeproj"CONFIGURATION_INHOUSE="Release"SCHEME="xxx"ARCHIVE_PATH="$&#123;PRO_DIR&#125;/archivePath/$&#123;SCHEME&#125;.xcarchive"EXPORT_PATH="$&#123;PRO_DIR&#125;/exportPath"/usr/bin/security unlock-keychain -p "jenkins" "/Users/Shared/Jenkins/Library/Keychains/login.keychain"xcodebuild clean -project $XC_PROJECT_DIR -scheme $&#123;SCHEME&#125; -configuration "$&#123;CONFIGURATION_INHOUSE&#125;" -archivePath "$&#123;ARCHIVE_PATH&#125;"xcodebuild -project $XC_PROJECT_DIR -scheme $&#123;SCHEME&#125; -configuration "$&#123;CONFIGURATION_INHOUSE&#125;" -archivePath "$&#123;ARCHIVE_PATH&#125;" archivexcodebuild -exportArchive -archivePath "$&#123;ARCHIVE_PATH&#125;" -exportOptionsPlist "$&#123;PRO_DIR&#125;/packageRelease.plist" -exportPath "$&#123;EXPORT_PATH&#125;" 如果工程用了pod之类的管理 123456789101112CURRENT_DIR=$(pwd)PRO_DIR = $&#123;CURRENT_DIR&#125;WORKSPACE_DIR="$&#123;PRO_DIR&#125;/*.xcworkspace"CONFIGURATION_INHOUSE="Release"SCHEME="xxx"ARCHIVE_PATH="$&#123;PRO_DIR&#125;/archivePath/$&#123;SCHEME&#125;.xcarchive"EXPORT_PATH="$&#123;PRO_DIR&#125;/exportPath"/usr/bin/security unlock-keychain -p "jenkins" "/Users/Shared/Jenkins/Library/Keychains/login.keychain"xcodebuild clean -workspace $&#123;WORKSPACE_DIR&#125; -scheme "$&#123;SCHEME&#125;" -configuration "$&#123;CONFIGURATION_INHOUSE&#125;" -archivePath "$&#123;ARCHIVE_PATH&#125;"xcodebuild -workspace $&#123;WORKSPACE_DIR&#125; -scheme "$&#123;SCHEME&#125;" -configuration "$&#123;CONFIGURATION_INHOUSE&#125;" -archivePath "$&#123;ARCHIVE_PATH&#125;" archivexcodebuild -exportArchive -archivePath "$&#123;ARCHIVE_PATH&#125;" -exportOptionsPlist "$&#123;PRO_DIR&#125;/packageRelease.plist" -exportPath "$&#123;EXPORT_PATH&#125;" 第三方推荐使用 fastlane]]></content>
      <categories>
        <category>自动化</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift入门篇]]></title>
    <url>%2FSwift%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[变量申明变量用var，常量用let；可以显示指明变量数据类型，也可以隐式由变量赋值决定。如果是可以为nil的变量，需要用可选符号?修饰。12345678910111213141516 let a: NSInteger = 12 var b = 13 b = 15 print(a+b) //2***********? var mayNilStr: String? = "hello"// var str: String = "world" mayNilStr = nil// str = nil print("\(mayNilStr)") //3********** ??(如果变量为nil，则取？？之后的值) var yourName :String? = nil yourName = "Tom" let defaultName = "Jack" let greet = "hello \(yourName ?? defaultName)" print(greet) 数组和字典数组和字典申明时可以显示指明元素、键值的数据类型，也可以隐式由包含的元素决定。1234567891011121314151617181920212223//1.可变数组和字典var shopping = ["catfish","water","tulips","blue paint"]shopping[0] = "beer"var dic1 = ["name": "Jack", "age": 12, "school": "Harverd"]dic1["key1"] = 8888.88print("shopping arr \(shopping)")print("dic1 list is \(dic1)")//2.空数组和空字典var emptyArray = [String]()var emptyDictionary = [String:Float]()emptyArray.append("111")emptyArray.insert("222", atIndex: 1)emptyDictionary["salary"] = 112.0/*var shoppingList = []var dicList = [:]*/print(emptyArray)print(emptyDictionary) 类型转换不同数据类型的转换，可以通过函数或者转义符实现。1234567891011121314//1********* 函数let label = "the width is "let width = 12let widthLabel = label + String(width)print(widthLabel)//2********** \()let apples = 3let oranges = 5let appleSummary = "I have \(apples) apples.\n"let orangeSummary = "I have \(oranges) oranges\n"let summary = "I have \(apples+oranges) pieces of fruit."print(appleSummary)print(orangeSummary)print(summary) 条件控制和for循环中，..&lt;表示小于，...表示小于等于。switch语句不在需要break并且支持模糊匹配等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//1 let scores = [12,35,86,98,13] for score in scores &#123; if score &lt; 60 &#123; print("\(score) is C") &#125;else if score &lt; 80 &#123; print("\(score) is B") &#125;else &#123; print("\(score) is A") &#125; &#125; //2 var c = 1000; while (c &gt; 0) &#123; c -= 100; &#125; print("final c value is \(c)") //3 let vegetable = "red pepper" switch vegetable &#123; case "celery" : print("Add some rausins and make ants on a log") case "cucumber", "watercress" : print("That would make a good tea sandwich") case let x where x.hasSuffix("pepper") : print("It is a spicy \(x)?") default : print("Everything tastes good in soup") &#125; //4 let numbers = [ "num1":[1,2,3,5,6,4,9,8], "num2":[12,15,17,86,23,11,90], "num3":[876,123,234,124,242,634] ] var largestNum = 0 for (_,kind) in numbers &#123; for num in kind &#123; if (num &gt; largestNum) &#123; largestNum = num; &#125; &#125; &#125; print("the largest num is \(largestNum)"); //5 var n = 2 repeat &#123; n = n*2 &#125;while n &lt; 100 print("final n is \(n)") //6 ****** ..&lt;小于 ...小于等于 var loop1 = 0 for i in 0..&lt;4 &#123; loop1 += i; &#125; print("loop1 value is \(loop1)") var loop2 = 0 for i in 0...4 &#123; loop2 += i; &#125; print("loop1 value is \(loop2)") 函数函数参数动态确定。可以作为参数或者返回值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func parameterFunction(name: String,age: Int16) -&gt; String &#123; return "your name is \(name), and age is \(age)"&#125;func calculateStaticstics(scores: [Int]) -&gt; (min: Int,max: Int,sum: Int) &#123; var min = 0 var max = 0 var sum = 0 for score in scores &#123; sum += score if (score &gt; max) &#123; max = score &#125; if (score &lt; min) &#123; min = score &#125; &#125; return (min,max,sum)&#125;func testDynamicParameter(numbers: Int...) -&gt; Int &#123; var sum = 0 for num in numbers &#123; sum += num &#125; if numbers.count &gt; 0 &#123; return sum/numbers.count &#125; return 0&#125;/** 返回值为函数 */func functionCanbeReturnType() -&gt; ((Int) -&gt; Int) &#123; func theReturnFunc(age: Int) -&gt; Int &#123; return age + 5 &#125; return theReturnFunc&#125;/** 参数为函数 */func functionCanbeParameter(lists:[Int],condition:((Int) -&gt; Bool)) -&gt; Bool &#123; for item in lists &#123; if (condition(item)) &#123; return true &#125; &#125; return false&#125; 类类中可以声明属性和方法等，可以创建构造函数和析构函数等123456789101112131415161718192021222324252627282930313233//类class Shape &#123; //property var numberOfSides = 0 var name: String? = nil var age: Int let extralProperty = 1 //构造函数 init(name: String)&#123; self.name = name self.age = 12 &#125; init(age: Int) &#123; self.age = age; &#125; init(name: String, age: Int) &#123; self.name = name self.age = age &#125; //实例销毁前的cleanup方法 deinit &#123; print("deinit method \(self.name)") &#125; //fucntion func shapeDescription() -&gt;String &#123; return "the shape side num is \(numberOfSides),name is \(name)" &#125;&#125; 继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Squar: Shape &#123; var sideLength: Double = 0.0 //property set and get method var perimeter: Double &#123; get &#123; return 4*sideLength &#125; set &#123; sideLength = sideLength/2 &#125; &#125; //enum(支持嵌入方法) enum Rank: Int &#123; case Ace = 1 case Two,Three,Four,Five,Six,Seven,Eight case Jack,Tom func simpleDescription() -&gt; String &#123; switch self &#123; case .Ace: return "ace" case .Jack: return "jack" case .Tom: return "tom" default: return String(self.rawValue) &#125; &#125; &#125; //struct struct Card &#123; var rank: Rank func simpleDescription() -&gt; String &#123; return "The \(rank.simpleDescription())" &#125; &#125; init(sideLength: Double, name: String) &#123; self.sideLength = sideLength; super.init(name: name) &#125; override func shapeDescription() -&gt; String &#123; return "override shape description" &#125;&#125; 协议123456789101112131415//声明协议protocol testProtocol &#123; var simpleProtocolMethod1: String &#123; get &#125; mutating func adjust()&#125;//实现协议class complishProtocol: testProtocol &#123; var simpleProtocolMethod1: String = "a very simple class" func adjust() &#123; simpleProtocolMethod1 += " Now 100% adjus" &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode的BuildSetting配置说明]]></title>
    <url>%2Fxcode%E7%9A%84BuildSetting%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[是否采用ARC 某个文件采用ARC，可以在Build Phases中的Compile Sources中找到该类，双击修改Compiler Flags为-fobjc-arc。 某个文件采用MRC，可以在Build Phases中的Compile Sources中找到该类，双击修改Compiler Flags为-fno-objc-arc。 全局宏定义一个workspace/project如果包含多个target或者scheme，可以在BuildSetting-&gt;Preprocessing-&gt;Preprocessor Macros中定义自己的宏来区别对待多target喝scheme等 第三方库路径配置有时第三方库（一般是.a之类的)引入时，查找路径没配好，可能导致编译失败。可以在BuildSetting-&gt;SearchPaths中修改库的查找路径为相对路径（不要用本地的绝对路径）]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios各种指针说明]]></title>
    <url>%2Fios%E5%90%84%E7%A7%8D%E6%8C%87%E9%92%88%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[strong、weak、unsafe_unretained、autoreleasing、copy说明 strong 指针的默认类型。该指针指向的对象在指针存活期间一直存在，不会被销毁。 weak 当没有strong指针指向对象时，weak指针指向的对象将被销毁，同时weak指针为变为nil。 unsafe_unretained 该指针指向的对象销毁时，该指针不会被置为nil，而是被挂起(类似野指针)。最好别用 autoreleasing 一般指向函数的参数类型为id *并且自动释放的参数。 copy 类似strong，但是会复制一份新的对象（即指向新的内存地址），新指向的对象存活期同strong。 参考链接Apple]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆和栈的区别]]></title>
    <url>%2F%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[堆栈栈用于静态内存分配，堆用于动态内存分配，它们都存储在内存RAM里。 栈 栈上面的变量一般编译时就分配好了(如函数临时变量等)。栈遵循LIFO（后进先出），非常方便管理。 栈的内存分配一般由系统管理，开发者无需关心。 读取栈上的变量速度很快。 当一个方法function被调用时，它会被push进栈中，该方法中的参数和局部变量存储在栈中，当方法执行完后，该方法pop出来，相应的栈空间被释放。 堆 堆上的变量，一般在程序运行期分配。 读取堆上数据速度较慢。 堆上的元素能够在任何时候被读取，开发者也能够在任何时候申请堆内存空间并且释放申请的空间，所以管理堆上的变量比较复杂。 通常我们说的内存管理实际上是指堆内存管理。 堆的大小仅受限于虚拟内存的大小。 说明多线程开发中，每一个线程都有自己独立的栈，但是它们共享堆。]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios app 性能优化的几个建议]]></title>
    <url>%2Fios-app-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E4%B8%AA%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[参考链接raywenderlich 优化建议当你开发了几款app后，是否考虑过怎样才能提高自己的app的性能。在开发的过程中，只要我们注意一些要点，可以很轻松地开发出性能优雅的app。这篇文章介绍了23个提高app性能的tips。 使用ARC和retain/release说拜拜。 使用重用机制特别是tableview/collectionview的cell，必须使用重用机制。 view的Opaque属性设置为YES不要在一个xib或者storyboard放置太多的东西因为每次系统加载xib到内存的时候，所有相关的内容都会加载（不管是否展现）,并且相关联的图片等资源也会被加载到内存（图片等还会缓存），很可能导致内存暴涨。 不要阻塞主线程耗时等操作在分线程执行，只有需要刷新界面是才在主线程。学会多线程开发和异步操作很有必要。 尽可能使图片的大小和imageview一样大网络下载的图片，可以先重画为imageview一样大小在显示。因为imageview拉伸或缩小图片代价较大，特别是当imageview嵌套在UIScrollview里的时候。 选用合适的数据容器。容器说明123* NSArrayi:有序的。能搞按照索引快速查找元素。按照值查找很慢，插入和删除很慢* NSDictionary:无序的。键值对存储。按照key可以快速查找。* NSSet: 无序的。按照值可以快速查找，插入和删除很快。 服务器和客户端采用GZIP压缩可以减少网络交互的等待时间和流量。 尽量重用view。重复生成相同模板的view时，可以参照UITableview的重用机制，自己写一套reuse机制。只有在需要时才加载相关view，无关的view只有需要才加载。（如果为了更好的用户体验，在某些情况下可以预加载某些view并让它隐藏，需要时才显示） 缓存，缓存，缓存服务器的图片下载完成并缓存，以后就可以快速读取并加载。tableviewcell的高度也可以缓存。 考虑图片资源和绘图的代价某些效果是切图好还是代码绘制好，需要衡量下 响应系统发出的内存不足的警告如果收到内存不足的通知，需要马上释放缓存及其它可以再次创建的对象。 重用一些初始化比较慢的对象NSDateFormatter/NSCalendar等，一般可以在你的类中添加一个相应的property即可。12345678910111213141516171819202122// in your .h or inside a class extension@property (nonatomic, strong) NSDateFormatter *formatter;// inside the implementation (.m)// When you need, just use self.formatter- (NSDateFormatter *)formatter &#123; static NSDateFormatter *formatter; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy"; // twitter date format &#125;); return formatter;&#125;//这里用GCD可以避免多线程调用重复alloc的问题（如果某个属性不会被多个线程同时调用，不用这么复杂），如下：- (NSDateFormatter *)formatter &#123; if (! _formatter) &#123; _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @"EEE MMM dd HH:mm:ss Z yyyy"; // twitter date format &#125; return _formatter;&#125; 游戏开发，使用sprite sheets尽量避免数据结构的来回转换服务器的json数据最好是不做处理就能直接使用，可以减少很多中间的转换过程。（如:json转成model）（汗!个人还是推荐转成model） 选择合适的数据类型服务器端发来的数据类型常见的有json和xml，具体看情况选择。xml支持边下载边解析，json必须下载完成才能开始解析。通常还是选择json 选择合适的背景图如果你有一张全屏的背景图，在底层价格UIImageView更好123// You could also achieve the same result in Interface BuilderUIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"background"]];[self.view addSubview:backgroundView]; 如果你有一张较小的带颜色的图，采用背景色较好1self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@"background"]]; 设置阴影路径当需要给一个view增加阴影效果时，你会怎么做？大部分的开发者会这样写：123456789#import &lt;QuartzCore/QuartzCore.h&gt;// Somewhere later ...UIView *view = [[UIView alloc] init];// Setup the shadow ...view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);view.layer.shadowRadius = 5.0f;view.layer.shadowOpacity = 0.6; 看起来很简单，不是吗？但糟糕的是，这样并不好。CoreAnimation框架需要耗费不小代价才能绘制出阴影。好消息是，有一种更简单的方法：设置阴影路径。1view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath]; 缺点是，每次frame改变后，都需要更新shadow path。 优化tableview为了使tableview滑动更平滑，需要确保下面几项 cell复用 view的opaque属性尽可能设置为YES 避免渐变、图片伸缩、离屏渲染 如果cell高度不变，缓存计算出的高度 如果cell展示的内容包含网络请求的内容，缓存并且异步加载 阴影用shadow path 尽可能减少cell的subviews数量 在cellForRowAtIndexPath方法尽量少做事，如果必须做，尽可能缓存耗时操作的结果。 抽象出合理的数据结构来展示信息 直接设置rowHeight、SectionFooterHeight、SectionHeaderHeight的值，不要调用相应的代理delegate 选择合适的数据存储器当你需要存储/读取大量数据的时候，你会怎么做？一般有以下几个选择: 用NSUserDefaults存储 用格式化文件存储（如XML、JSON、Plist等） 归档（实现NSCoding协议） 数据库，如SQlite等 用IOS特有的Core Data NSUserDfault只适用于存储少量的数据。当你需要存储大量的数据时，其它选项更好格式化文件存储，缺点是你必须将整个文件读取到内存才能开始解析。好吧，那么NSCoding？但是它也是文件存储，缺点通格式化文件一样。最好的选择就是SQlite或CoreData。通过这种存储，你可以只加载需要的数据，并且不用写复杂的查询等语法。在性能方面，sqlite和coreData差不多。通常苹果建议使用coreData，但你也可以使用轻量型的Sqlite。如果你决定采用Sqlite存储，可以参考FMDB 复杂耗时操作异步执行@autoreleasepool可以保证块中的内容合理释放参考123456789NSArray *urls = &lt;# An array of file URLs #&gt;;for (NSURL *url in urls) &#123; @autoreleasepool &#123; NSError *error; NSString *fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; /* Process the string, creating and autoreleasing more objects. */ &#125;&#125; 图片是否在内存缓存ios有两种加载图片的方法 imageName imageWithContentOfFile 那么，这两种方法有什么区别呢？imageName会将加载的图片缓存到内存中，而imageWithContentOfFile仅仅加载图片，不缓存。如果加载大图并且调用次数很少，建议用imageWithContentOfFile。小图或者经常调用的图可以用imageName加载。]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git仓库迁移]]></title>
    <url>%2Fgit%E4%BB%93%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[说明如果你想从别的git托管服务器哪里复制一份源代码到新的git托管服务器上，可以通过以下步骤实现。 git仓迁移 从原地址克隆一份裸版本，比如原版本托管在github上。 1git clone --bare git://github.com/username/project.git 到新的git服务器上创建一个空的新项目，比如gitCafe服务器。 以镜像推送的方式，上传代码到gitCafe服务器上 12cd project.gitgit push --mirror git@gitcafe.com/username/newproject.git 删除本地之前克隆下来的裸版本 12cd ..rm -rf project.git 到新服务器gitCafe上找到clone地址，直接Clone到本地就可以了。 1git clone git@gitcafe.com/username/newproject.git 结束这种方式可以保留原版本库中的所有内容。]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac电脑隐藏文件的方法]]></title>
    <url>%2Fmac%E7%94%B5%E8%84%91%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[工具terminal（终端） 显示mac电脑所有隐藏文件1defaults write com.apple.finder AppleShowAllFiles -bool true 隐藏mac电脑所有隐藏文件1defaults write com.apple.finder AppleShowAllFiles -bool false 主动隐藏某个文件(filename为想隐藏的文件的绝对路径名)1chflags hidden filename 主动取消某个文件的隐藏(filename为想隐藏的文件的绝对路径名)1chflags nohidden filename]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用方法]]></title>
    <url>%2Fgit%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[git简介git官网有全套教程和说明，有兴趣的自己研究。如果你不适应命令行，可以使用GUI工具，如SourceTree。 官方文档中文官方文档。官方文档非常详细,需要仔细阅读。 常用命令 切换分支 1git checkout branchName 合并分支(将branchName合并到当前的分支) 1git merge --no-ff branchName 新建分支并切换到新建的分支 1git checkout -b branchName 删除分支 12git branch -d branchName //删除本地的分支git push &lt;shortname&gt; :branchName //删除远程分支 追加提交 123git commit -m &apos;initial commit&apos;git add forgotten_filegit commit --amend 取消暂存 1git reset HEAD fileName 撤销对文件的修改(**不可逆**) 1git checkout -- fileName 查看远程仓库的url 1git remote -v 添加新的远程仓库 1git remote add &lt;shortname&gt; &lt;url&gt; 拉取远程仓库的内容 12git fetch &lt;shortname&gt; [branchName] //不会合并，只拉取git pull &lt;shortname&gt; [branchName] //拉取并且合并 推送到远程仓库 1git push [shortname] [branch-name] 移除某个远程仓库 1git remote rm &lt;shortname&gt; 重命名远程仓库git remote rename 1git remote rename oldShortName newShortName 创建标签 1234git tag -a 1.2.0 -m &apos;my version 1.2.0&apos;//在之前的某次提交commitId打标签git tag -a 1.1.9 9fceb02 推送标签到远程仓库 12git push &lt;shortname&gt; --tags //推送所有本地标签git push &lt;shortname&gt; 1.2.0 //推送特定的标签 检出到特定的标签git checkout -b [branchname] [tagname] 1git checkout -b branchName 1.2.0 删除标签 12git tag -d tagName //删除本地的taggit push &lt;shortname&gt; --delete tag tagName //删除远程的tag 设置git别名 12345git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.unstage &apos;reset HEAD --&apos; 版本回退 1git reset --hard HEAD ~N //N为数字，回退N个版本 撤销某次提交 1git revert commitId 文件权限不纳入版本管理 1git config core.filemode false 子模块 12git submodule add 仓库url 本地路径 //添加子模块git submodule update —init —recursive //下载带有子模块的repo后 暂存。当某个任务完成了一半，但突然插进来一个其它的紧急任务，这个时候你又不能将未完成的工作commit，暂存stash就非常有用了。 1234567git stash save &quot;some comments for this stash&quot; //暂存并添加注释，方便后续取出git stash list //查看当前所有的暂存git stash apply stash@&#123;0&#125; //取出最后一次的暂存(具体想取出哪次暂存，通过git stash list查看)git stash drop stash@&#123;0&#125; //将最后一次的暂存从暂存列表清除git stash clear //清除所有暂存git stash pop //取出最后一次暂存，并将其从暂存列表清除git stash branch newBranch stash@&#123;0&#125; //取出最后一次暂存并切换到新的分支newBranch，同时将其从暂存列表清除 附录查看git的总提交次数(可以作为版本号之类的)1git rev-list head | sort | wc -l 查看git最后一次提交的hash值1git rev-list head | head -1]]></content>
      <categories>
        <category>版本管理工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app提交apptore的简介]]></title>
    <url>%2Fapp%E6%8F%90%E4%BA%A4appstore%E7%9A%84%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[申请开发者账号 登陆苹果官网Apple Develper,注册开发者账号 生成certificate证书(用系统的keychain生成.CSR文件，该文件最好长期保存，后续加入新app或者证书过期需重新生成时都需要该文件，这样服务器就不用更新推送证书了，而且兼容之前老证书发的包)，生成对应的证书打包提交AppStore。（个人开发者账号打的包提交appstore，企业开发者账号打的是Inhouse证书的包，无需通过appstore，可以直接通过fir等分发就行） 登陆Itunes Connect,创建App Itunes Connect注意事项 AppIcon,尺寸1024*1024px,包括Ipad和Iphone Screenshots,app截图，最多5张，以竖屏为例子 Iphone4/4s: 640*960px Iphone5/5s: 640*1136px Iphone6: 750*1334px Iphone6 plus: 1242*2208px Ipad: 1536*2048px 基本信息 app的描述 关键字，多个关键字逗号隔开，用于appStore搜索 技术支持网站 推广网站 可选 隐私声明网站 可选 app的类别，如教育-工具 年龄评级，勾选相关项，系统会自动计算 设置价格 根据实际产品，选择性设置In-AppPurchase、Game Center、Newsstand等 可选 发布的市场。默认全球appStore上线，如果要求在特定区域的市场上线，需要提交.geojson格式的文件 可选 发布方式。默认是审核通过就发布到appStore，也可以选择手动发布 版权信息 版权所有，如“2015 Acme Inc” 负责人姓名、手机、邮箱 审核 审核时遇到问题时的联系人：姓名、手机、邮箱 审核时的测试账号(长期有效，最高权限) 审核时的注意事项和备注 将通过测试验收的工程，Xcode等工具打包并添加相应的证书，提交appStore 确认符合苹果审核要求 进入Itunes Connect，确认信息完整后，点击右上角的提交审核按钮]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocoapods安装和使用入门篇]]></title>
    <url>%2Fcocoapods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[cocoapods是Xcode管理第三方类库的工具（当然也可以管理自己封装的私有库），能够处理类库之间的依赖关系，方便多个类库的升级和管理。它是用ruby语言编写的。 一、更换ruby源打开命令行工具terminal，依次输入下面的命令 ruby官方源https://rubygems.org/很可能被墙了淘宝的ruby源https://ruby.taobao.org/已停更，建议使用最新的ruby-china源http://gems.ruby-china.org/ 12gem sources --remove https://rubygems.org/gem sources --add http://gems.ruby-china.org/ 接着输入gem sources -l即可看到如下结果 123*** CURRENT SOURCES ***http://gems.ruby-china.org/ 如果想用ruby-china的https源https://gems.ruby-china.org/，需要给gem配置证书,具体参考github-ruby-ssl 顺便更新下gem，输入命令sudo gem update --system即可。（需升级） 最近升级cocoapods到1.2.0出了点问题，就是由于gem版本太低导致的，所以尽量保持gem也是最新版本。 二、安装cocoapods 安装最新版本sudo gem install -n /usr/local/bin cocoapods 安装指定版本sudo gem install -n /usr/local/bin cocoapods --version 1.0.0 三、下载pod仓库索引输入pod setup开始下载索引表，该过程耗时较长，请耐心等待。如果下载一个小时还遥遥无期，那你可以从别人做的镜像下载索引表，步骤如下123pod repo remove masterpod repo add master https://git.coding.net/jasper/CocoaPods.gitpod repo update 上面从镜像下载索引表的命令同样适用于私有库（如：公司内部搭建的各种私有库git索引表），只需输入pod repo add [repoName] url 时repoName不一样就行。cocoapods支持多个源（官方源和私有源等） 四、更新pod索引表每天都有人上传和更新pod仓库，所以最好定时更新pod索引表1pod repo update 五、升级cocoapods版本其实升级和安装的命令一样 升级到最新版本sudo gem install -n /usr/local/bin cocoapods 升级到指定版本sudo gem install -n /usr/local/bin cocoapods --version 1.0.0 六、使用cocoapods工程根目录下新建文件Podfile（该文件无后缀名）,编辑Podfile里的内容 pod版本低于1.0.0 12platform:ios, &apos;7.0&apos;pod &apos;AFNetworking&apos;, &apos;~&gt; 2.3.1&apos; pod版本大于等于1.0.0 1234567891011121314151617181920212223#官方源source &apos;https://github.com/CocoaPods/Specs.git&apos;#如果有内部私有源，再添加一条source即可platform :ios, &apos;7.0&apos;#use_frameworks!inhibit_all_warnings!target &apos;targetName&apos; dopod &apos;AFNetworking&apos;, &apos;~&gt; 2.3.1&apos;end#修改工程配置等，根据情况配置，可选post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;] = &apos;7.0&apos; if target.name == &apos;OpenCore&apos; config.build_settings[&apos;ENABLE_BITCODE&apos;] = &apos;NO&apos; end end endend 七、安装第三方库使用pod install安装第三方库。如果修改过Podfile文件(增加/删除podame)，需要使用pod install，而不是pod update。update命令若不指定podName则更新所有有新版本的库pod update [podName] 使用pod install后，需要点击*.xcworkspace打开工程，而不是以前的*.project 八、卸载cocoapods输入命令sudo gem uninstall cocoapods即可卸载cocoapods 每次执行pod install后，Podfile.lock都会更新。如果团队使用git/svn之类的版本管理工具，必须将Podfile.lock纳入版本管理。否则，团队中不同的人看到的cocoapods管理的第三方库版本可能不一致，甚至报错。 九、gem安装其它库的写权限问题gem install 时加入参数 -n /usr/local/bin 指定安装目录即可。(eg：sudo gem install -n /usr/local/bin cocoapods)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS生成静态库.a文件]]></title>
    <url>%2FIOS%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%BA%93-a%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[说明库是程序代码的合集，常见的有开源库和闭源库，其中.a就是闭源库（无法看到具体实现方法），而Github上的代码基本都是开源库。静态库执行时会被复制到可执行文件中，多次调用则会出现冗余拷贝，不建议使用静态库。可以使用动态库.dylib(动态库貌似通不过appstore审核)或者源码。 生成.a文件一个.a文件，要想兼容各种不同的cpu架构，需要包含各种指令集(amrv7/armv7s/arm64/i386/x86_64等)。常用的查看和合并.a文件的指令lipo。 步骤和说明 打开Xcode创建新工程，选择相应的系统，本文以IOS系统为例。选择Framework&amp;Library中的Cocoa Touch Static Library。接着输入工程名字即可。 新建文件夹。暂时取名StaticDemo,所有需要打包生成.a的文件都将放在该目录下。 在StaticDemo目录下分别创建3个类TestPublicClass/TestObj1/TestObj2，其中TestPublicClass.h准备对外公开。 随便选择一个模拟器(如iphoen6)，Command+B编译完成后就会生成.a文件，该文件是用于模拟器的（Release版本可以不合并），然后选择Generic IOS Device，再次编译完成，会生成.a文件，该文件是用于真机的。 他们的路径可以右键.a文件在Finder中查看。 查看.a文件支持的arm指令集，使用lipo -inof *.a,如: 12lipo -info libGenerateStaticLib.aArchitectures in the fat file: libGenerateStaticLib.a are: armv7 arm64 合并不同架构的.a文件，使用命令lipoi -create source1.a source2.a -output dest.a，如： 1lipo -create Debug-iphoneos/libGenerateStaticLib.a Debug-iphonesimulator/libGenerateStaticLib.a -output libGS.a 合并后，可以通过lipo -info *.a确认 12lipo -info libGS.aArchitectures in the fat file: libGS.a are: armv7 x86_64 arm64 可以看到.a已经合并成功。接着将头文件TestPublicClass.h复制出来，.a文件打包就大功告成了。 iphone设备arm架构表参考链接 device name ARM iphone4s及之前 armv7 iphone5/5c armv7s iphone5s/6/6s/6p/se arm64 结束arm指令能够向下兼容，所以只需32和64位各一个.a文件就行了。目前xcode7.2默认的architecture为armv7和arm64，已经能够适应任何iphone设备了。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客之搜索引擎推广]]></title>
    <url>%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8E%A8%E5%B9%BF%2F</url>
    <content type="text"><![CDATA[说明前段时间抽空搭建了个人博客，来回也折腾了不少时间，好不容易写了点东西，发现搜索引擎居然不能找到自己写的东西，于是就开始研究了下搜索引擎推广。 平台我的博客采用Hexo框架搭建的，存储在Github上。然后自己买了个域名，现在博客主页基本配置完成我的主页。 确认自己网站是否被收录在浏览器的搜索框输入site:zyoung.me，查看搜索结果就能明白了。（这个域名是我的，大家换成自己的网站域名就可以了）。提供下Google和Baidu的网站验证入口 Google搜索引擎提交入口 Baidu搜索引擎提交入口 如果你的博客也在gitHub上，百度搜索引擎估计不好用（Github屏蔽了百度的抓取)。 验证网站一般验证域名所有权有很多方法，但是最简单的还是下载html文件到网站的根目录下。如果你的博客是hexo的框架搭建的，需要注意: 下载的html文件需要放在source目录下，而不是手动添加到根目录下，类似的CNAME也需要放在source目录下。 由于hexo发布时，默认会对文件进行格式化等操作，但是我们下载的验证文件是不允许做格式化等操作的（会导致验证文件内容更改），否则验证无法通过。需要告诉hexo不要格式化特定的文件，需要在文件内容加入以下内容:12layout: false--- 所以，最终Google的验证文件内容cat出来为123layout: false---google-site-verification: google*******.html 站点地图sitemap.xml验证网站后，一般还需要生成站点地图，进一步方便搜索引擎抓取网站的内容。如果使用hexo的小伙伴，可以直接使用插件，发布时会自动生成sitemap。12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 生成的sitemap文件在public目录 结束语暂时就这么多吧，其他的比如百度push、结构化数据标记等高阶内容，暂时还没研究]]></content>
      <categories>
        <category>疑难解答</category>
      </categories>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown学习笔记]]></title>
    <url>%2Fmarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[markdown的目标是实现: 易读易写1、兼容html。A paragraph in HTML displayed as code 1&lt;p&gt;A paragraph in &lt;b&gt;HTML&lt;/b&gt; displayed as code&lt;/p&gt; 2、不在markdown涵盖范围之内的标签，都可以直接在文档里用html编写，不需要额外标注。3、html文件中，有两个字符需要特殊处理：&lt;&amp;lt;和&amp;&amp;amp;。&lt;用于起始标签，&amp;用于标记html实体。插入版权符号&copy;&amp;copy;4、段落的前后要有一个以上的空行，普通段落不需要空格或制表符来缩进。 5、支持两种标题的语法，类Setext和类atx形式。例如：12345This is an H1============This is an H2------------ 任何数量的=和-都可以有效果。也可以选择类Atx形式在行首插入1到6个#,对应1到6阶标题，例如:12# 这是H1###### 这是H6 6、区块引用Blockquotes，在段落前加上&gt;来标记区块引用。可以叠加嵌套，例 This is the first level of quoting. This is nested blockquote. Back to the first level. 7、列表markdown支持无序和有序列表。无序列表使用星号、加号或减号作为列表标记123* Red* Green* Blue 有序表则使用数字接着一个英文句点:1231. Bird2. Mchale3. Parish 列表项中可以包含多个段落，每个分类下的段落必须缩进4个空格或1个制表符123456781. This is a list item with two paragraphs. Lorem ipsum dolor sit amet,consiter adipiscing elit. A;iquam henderit mi posure lecture Greateful. Another paragraph2. Suspend id is what a good.3. Third item 8、建立分割线。可以在一行中用三个以上的星号、减号、底线来建立分割线。也可以在星号和减号之间插入空格123***---* * * 9、链接[tittle](url)markdown中文网站 markdownmarkdown的VIM编辑器 vim-markdown 10、图片![title](imgUrl)This is an image 11、表格 Colum1 Colum2 Colum3 Colum4 中对齐 中对齐 左对齐 右对齐 中对齐 好的好的 哈 简单介绍 中对齐 但是 动画 哈哈 表格代码如下:12345|Colum1|Colum2 |Colum3 | Colum4 ||:----:|:----: |:----- | -------:||中对齐|中对齐 |左对齐 | 右对齐 ||中对齐|好的好的|哈 | 简单介绍||中对齐|但是 |动画 | 哈哈 | 12、锚点链接1234之前的第一条定义如下：&lt;a name=&quot;html&quot;&gt;1、兼容html。&lt;/a&gt;然后可以直接锚点跳转过去，使用方法如下:[锚点名称](#锚点名) 13、视频链接其实就是插入视频截图然后将链接设置为视频的实际地址[![vedio](/ios10/ios10_preview.png)](http://open.163.com/movie/2011/10/F/G/M7GF17HPS_M7GHGQTFG.html)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
